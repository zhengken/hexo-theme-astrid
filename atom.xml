<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Astrid</title>
  
  
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://blog.floretten.com/"/>
  <updated>2018-02-28T04:29:20.876Z</updated>
  <id>http://blog.floretten.com/</id>
  
  <author>
    <name>Levan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机系统中的字长</title>
    <link href="http://blog.floretten.com/2017/Word_Size_in_Computing_System/"/>
    <id>http://blog.floretten.com/2017/Word_Size_in_Computing_System/</id>
    <published>2017-08-27T08:04:29.000Z</published>
    <updated>2018-02-28T04:29:20.876Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下计算机系统中各种字长的意义。</p><a id="more"></a><h2 id="字与字长"><a href="#字与字长" class="headerlink" title="字与字长"></a>字与字长</h2><p>字(word)是指在计算机中作为一个整体被存取、传送、处理的一组二进制数,是一串数字。而字长(word size)则是这串数字即一个字的位数它是计算机系统结构中的一个重要特性。字长是由CPU的类型所决定，不同的计算机系统的字长是不同的，常见的有8位、16位、32位、64位等，字长越长，计算机一次处理的信息位就越多，精度就越高，字长是计算机性能的一个重要指标。</p><p><strong>注</strong>：计算机系统中，字是一个基本单位，而字长是一种评价指标，注意区分。</p><h2 id="位与字节"><a href="#位与字节" class="headerlink" title="位与字节"></a>位与字节</h2><p>这里顺便提一下字节与位的概念。位(bit，简写为b)是计算机系统中最小的数据单位，也是存储器存储信息的最小单位，存放一位二进制数，即0或1。字节(Byte，简写为B)是计算机系统中表示存储容量的最常用的基本单位。一个字节由8位二进制数组成，一个字符占一个字节，一个汉字占两个字节。</p><p>常见的存储容量计算单位还有KB、MB、GB、TB，另外还有PB、EB、ZB、YB，这几个不是很常见。这些单位之间的换算进率均为1024，即2的10次幂。而B与b之间进率是8，即1B(yte)=8b(it)。在我们使用的应用中计算某种速率用的一般都是b，注意区别与B，不要别欺骗了，例如bps。</p><h2 id="四种字长"><a href="#四种字长" class="headerlink" title="四种字长"></a>四种字长</h2><p>机器字长：CPU一次能处理数据的位数，通常与CPU的寄存器位数有关，一般可以通过寄存器的位数来判断机器字长。<br>存储字长：存储器中一个存储单元(存储地址)所存储的二进制代码的位数，即存储器中的MDR的位数，而其中的二进制代码称作字。<br>指令字长：计算机系统中机器指令的二进制代码总位数，它取决于操作码的长度、操作数地址的长度和操作数地址的个数，不同的指令的字长是不同的。指令字长一般都取存储字长的的整数倍，如果取2倍，则需要2次访存取出一条指令。<br>数据字长：计算机系统中数据存储所占用的位数。</p><p><strong>注</strong>：操作系统的位数是操作系统可以寻址的位数，与机器字长是不一样的。选用多少位的操作系统要考虑处理器的架构和内存的大小。<br>64位操作系统为64位架构的计算机而设计，能够利用64位处理器的优势。但64位机器可以使用64位操作系统系统，也可以使用32位操作系统，而32位机器是无法使用64位操作系统的。<br>另外，<code>在满足前一条件下</code>，操作系统寻址空间最好大于或等于内存的大小，但不易过大，否则操作系统自身会占用大量内存影响机器的速度。如32位系统寻址空间大小位2的32次幂，即4G，但一般只识别3.25-3.75之间。因此4G及以下的内存空间一般安装32位系统。</p><p>冯诺依曼机中，指令和数据同等重要，都存放在存储器中，并可按地址寻访。<br>早期的计算机：指令字长 = 机器字长 = 存储字长。故访问某个存储单元便可取一条完整的指令或一条完整的数据，这些机器的指令字长是固定的，控制方式比较简单。<br>随着计算机的发展，存储容量增大，处理的数据类型增多，计算机指令字长发生很大变化。一台机器的指令系统可以采用位数不相同的指令，即指令字长是可变的，如单字节指令、多字节指令。控制这类指令的电路较为复杂，多字节指令则需要多次访存才能取出一条完整的指令，因此CPU速度下降。三者可能各不相同，但它们必须是字节的整数倍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下计算机系统中各种字长的意义。&lt;/p&gt;
    
    </summary>
    
      <category term="系统结构" scheme="http://blog.floretten.com/categories/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="字长" scheme="http://blog.floretten.com/tags/%E5%AD%97%E9%95%BF/"/>
    
      <category term="计算机系统" scheme="http://blog.floretten.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>更换畅言评论系统</title>
    <link href="http://blog.floretten.com/2017/Hexo_Change_to_Cyan/"/>
    <id>http://blog.floretten.com/2017/Hexo_Change_to_Cyan/</id>
    <published>2017-07-31T09:43:09.000Z</published>
    <updated>2018-03-08T13:55:33.627Z</updated>
    
    <content type="html"><![CDATA[<p>博客创建时使用多说评论，后收到官方通知其将停止服务。因为懒于管理，曾放弃评论功能，现使用畅言重新上线评论功能。</p><a id="more"></a><h2 id="畅言配置"><a href="#畅言配置" class="headerlink" title="畅言配置"></a>畅言配置</h2><p>关于这种比较完善的第三方系统配置，官方往往都有详细说明，再不济网上也有老司机们写好的教程，此处不再过多赘述。<br><strong>值得注意</strong>的是使用畅言必须提供网站的备案号，否则只能使用 15 天。毕竟现在国家网络信息管的紧，网站都需要备案的，使用独立的域名的司机们应该都备过案了。另外的福利是畅言有广告服务，同意其广告协议可以有广告收入，当然如果你不需要可以不用管它。</p><h3 id="注册获取通用代码"><a href="#注册获取通用代码" class="headerlink" title="注册获取通用代码"></a>注册获取通用代码</h3><p>畅言提供了桌面端、移动端、自适应等几类代码，可根据需要选择自己需要的。本站使用的是自适应的代码，就以此为例说明几点情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--PC和WAP自适应版--&gt;</span><br><span class="line">&lt;div id=<span class="string">"SOHUCS"</span> sid=<span class="string">"请将此处替换为配置SourceID的语句"</span> &gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> appid = <span class="string">'你的APPID'</span>;</span><br><span class="line"><span class="keyword">var</span> conf = <span class="string">'你的APPKEY'</span>;</span><br><span class="line"><span class="keyword">var</span> width = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line"><span class="keyword">if</span> (width &lt; <span class="number">960</span>) &#123;</span><br><span class="line"><span class="built_in">window</span>.document.write(<span class="string">'&lt;script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id='</span> + appid + <span class="string">'&amp;conf='</span> + conf + <span class="string">'"&gt;&lt;\/script&gt;'</span>); &#125; <span class="keyword">else</span> &#123; <span class="keyword">var</span> loadJs=<span class="function"><span class="keyword">function</span>(<span class="params">d,a</span>)</span>&#123;<span class="keyword">var</span> c=<span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>]||<span class="built_in">document</span>.head||<span class="built_in">document</span>.documentElement;<span class="keyword">var</span> b=<span class="built_in">document</span>.createElement(<span class="string">"script"</span>);b.setAttribute(<span class="string">"type"</span>,<span class="string">"text/javascript"</span>);b.setAttribute(<span class="string">"charset"</span>,<span class="string">"UTF-8"</span>);b.setAttribute(<span class="string">"src"</span>,d);<span class="keyword">if</span>(<span class="keyword">typeof</span> a===<span class="string">"function"</span>)&#123;<span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent)&#123;b.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> e=b.readyState;<span class="keyword">if</span>(e===<span class="string">"loaded"</span>||e===<span class="string">"complete"</span>)&#123;b.onreadystatechange=<span class="literal">null</span>;a()&#125;&#125;&#125;<span class="keyword">else</span>&#123;b.onload=a&#125;&#125;c.appendChild(b)&#125;;loadJs(<span class="string">"https://changyan.sohu.com/upload/changyan.js"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">window</span>.changyan.api.config(&#123;<span class="attr">appid</span>:appid,<span class="attr">conf</span>:conf&#125;)&#125;); &#125; &#125;)(); <span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>上面的代码中需要替换的有三处：SourceID、APPID、APPKEY：</p><ol><li>SourceID 就是文章获页面的唯一标识，就是数据库表中的(类似)主键，因为评论在数据库中存储要与对应的文章会页面匹配，否则会出现评论的混乱。对于 Hexo，可以把相关页的链接（如page.path/url_for(page.path)）或者标题（如page.title）作为 SourceID。</li><li>APPID和APPKEY在畅言的后台都可以获取。需要注意的是 APPKEY，在后台给的代码中，APPKEY 位置给出的是以<code>prod</code>开头的一串代码，而在其帮助文档中写的是 APPKEY ，虽然两串代码不相同，但都能实现功能，任选一种即可，建议使用 APPKEY。</li></ol><h3 id="安装其他插件"><a href="#安装其他插件" class="headerlink" title="安装其他插件"></a>安装其他插件</h3><p>除主体评论框外，畅言还提供了诸如评论数目、热门评论、热评用户等插件，可根据需要自行选择，本站只安装了评论数目，简单说一下注意事项。</p><p>关于评论数目的代码，畅言官方提供了三种，详情可访问<a href="http://changyan.kuaizhan.com/install/code/comment-count-code" target="_blank" rel="noopener">获取评论数代码</a>。主要就是两种情况：含评论框的页面和不含评论框的页面，前者适用于列表页，后者适用于详情页，至于原因那就是不言而喻了。经本站测试其实都使用<code>不含评论框那种代码</code>即可，不过<strong>需要注意</strong>的是，不要更改的标签名称，否则会出问题，这是本站已经测试过的，也是不得不吐槽的一点了。</p><p>更多插件可登录<a href="http://changyan.kuaizhan.com/labs/list" target="_blank" rel="noopener">畅言后台</a>获取。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客创建时使用多说评论，后收到官方通知其将停止服务。因为懒于管理，曾放弃评论功能，现使用畅言重新上线评论功能。&lt;/p&gt;
    
    </summary>
    
      <category term="HEXO博客" scheme="http://blog.floretten.com/categories/HEXO%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://blog.floretten.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>在前端开发中使用谷歌字体</title>
    <link href="http://blog.floretten.com/2017/Google_Fonts/"/>
    <id>http://blog.floretten.com/2017/Google_Fonts/</id>
    <published>2017-04-30T11:30:04.000Z</published>
    <updated>2018-02-28T04:47:39.158Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了如何使用谷歌的独门字体库神器！</p><a id="more"></a><h2 id="谷歌字体库"><a href="#谷歌字体库" class="headerlink" title="谷歌字体库"></a>谷歌字体库</h2><p>网站大概长这个样</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Google/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%2820%29.png" alt="Google Fonts"></p><p>网址在这</p><p><a href="https://fonts.google.com/" target="_blank" rel="noopener">Google Fonts</a></p><h2 id="在线使用"><a href="#在线使用" class="headerlink" title="在线使用"></a>在线使用</h2><p>访问谷歌字体网站，选择想要使用的字体，随后页面下方会弹出一个悬浮页面，里面提供了使用该字体的方法。</p><p>一种是HTML标签<code>link</code>引入，然后在css中使用<code>font-family</code>属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://fonts.googleapis.com/css?family=XXX"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://floretten-1252347631.costj.myqcloud.com/Google/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%2821%29.png" alt="link"></p><p>另一种是使用CSS的引入方式<code>@import</code>，然后同样是在css中使用<code>font-family</code>属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(<span class="string">'https://fonts.googleapis.com/css?family=XXX'</span>);</span><br></pre></td></tr></table></figure><p><img src="http://floretten-1252347631.costj.myqcloud.com/Google/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%2822%29.png" alt="@import"></p><h2 id="离线使用"><a href="#离线使用" class="headerlink" title="离线使用"></a>离线使用</h2><p>前面两种方式均是引入谷歌字体库的链接，我们也可以下载谷歌字体文件离线使用，谷歌字体提供了下载接口。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Google/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%2823%29.png" alt="下载字体"></p><p>下载之后用本地方式引入 css 中，即下面这种方式，其中<strong><em>xxx.eot/woff/ttf</em></strong>等即为下载的字体文件，根据下载的字体格式，选择性使用下面的代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">'xxx'</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'../fonts/xxx.eot'</span>);</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'../fonts/xxx.eot?#iefix'</span>) <span class="built_in">format</span>(<span class="string">'embedded-opentype'</span>),</span><br><span class="line">         <span class="built_in">url</span>(<span class="string">'../fonts/xxx.woff'</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>),</span><br><span class="line">         <span class="built_in">url</span>(<span class="string">'../fonts/xxx.ttf'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>),</span><br><span class="line">         <span class="built_in">url</span>(<span class="string">'../fonts/xxx.svg#xxx'</span>) <span class="built_in">format</span>(<span class="string">'svg'</span>);</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">    <span class="attribute">font-style</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文只介绍怎么用，至于能不能用就要看众多老司机们了，虽然大流氓曾经做过谷歌字体的代理，不过现在已经正式停止服务了。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Google/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%2825%29.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了如何使用谷歌的独门字体库神器！&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://blog.floretten.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="谷歌字体" scheme="http://blog.floretten.com/tags/%E8%B0%B7%E6%AD%8C%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>贝塞尔曲线初探</title>
    <link href="http://blog.floretten.com/2017/Cubic_Bezier/"/>
    <id>http://blog.floretten.com/2017/Cubic_Bezier/</id>
    <published>2017-04-01T07:32:10.000Z</published>
    <updated>2017-10-06T04:31:55.787Z</updated>
    
    <content type="html"><![CDATA[<p>使用 CSS 的 transition 时接触到贝塞尔曲线，初步总结一些学习心得。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 CSS 的 transition 时接触到贝塞尔曲线，初步总结一些学习心得。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://blog.floretten.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="贝塞尔曲线" scheme="http://blog.floretten.com/tags/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 插件收集</title>
    <link href="http://blog.floretten.com/2017/JS_Plugins/"/>
    <id>http://blog.floretten.com/2017/JS_Plugins/</id>
    <published>2017-03-28T02:30:14.000Z</published>
    <updated>2017-10-05T08:42:49.654Z</updated>
    
    <content type="html"><![CDATA[<p>汇集一波平时用过的 Javascript 插件，日后持续更新。</p><a id="more"></a><h2 id="Bootstrap-相关组件"><a href="#Bootstrap-相关组件" class="headerlink" title="Bootstrap 相关组件"></a>Bootstrap 相关组件</h2><ol><li><p>bootstrap-dualllistbox<br> 项目主页：<a href="http://www.virtuosoft.eu/code/bootstrap-duallistbox/" target="_blank" rel="noopener">duallistbox</a></p></li><li><p>bootstrap-progressbar<br> 项目主页：<a href="http://www.minddust.com/project/bootstrap-progressbar/" target="_blank" rel="noopener">progressbar</a></p></li><li><p>bootstrap-select<br> 项目主页：<a href="http://silviomoreto.github.io/bootstrap-select/" target="_blank" rel="noopener">select</a></p></li></ol><h2 id="页面访问效率"><a href="#页面访问效率" class="headerlink" title="页面访问效率"></a>页面访问效率</h2><ol><li><p>FastClick</p></li><li><p>lazyload<br> 项目主页：<a href="http://www.appelsiini.net/projects/lazyload" target="_blank" rel="noopener">lazyload</a></p></li></ol><h2 id="页面动画效果"><a href="#页面动画效果" class="headerlink" title="页面动画效果"></a>页面动画效果</h2><ol><li><p>wow.js<br> 项目主页：<a href="http://mynameismatthieu.com/WOW/" target="_blank" rel="noopener">WOW</a></p></li><li><p>scrollreveal<br> 项目主页：<a href="https://scrollrevealjs.org/" target="_blank" rel="noopener">scrollreveal</a></p></li></ol><h2 id="图片相关"><a href="#图片相关" class="headerlink" title="图片相关"></a>图片相关</h2><ol><li><p>lightGallery<br> 项目主页：<a href="http://sachinchoolur.github.io/lightGallery/" target="_blank" rel="noopener">lightGallery</a></p></li><li><p>Justified Gallery<br> 项目主页：<a href="http://miromannino.github.io/Justified-Gallery/" target="_blank" rel="noopener">Justified Gallery</a></p></li></ol><h2 id="页面绘图"><a href="#页面绘图" class="headerlink" title="页面绘图"></a>页面绘图</h2><ol><li>ichart.js<br> 项目主页：<a href="http://www.ichartjs.com/" target="_blank" rel="noopener">ichartjs</a></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>一个网站：<a href="http://www.jq22.com/" target="_blank" rel="noopener">jQuery插件库</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;汇集一波平时用过的 Javascript 插件，日后持续更新。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://blog.floretten.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Javascript" scheme="http://blog.floretten.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>分享一款 Hexo 主题</title>
    <link href="http://blog.floretten.com/2017/Hexo_Theme_Astrid/"/>
    <id>http://blog.floretten.com/2017/Hexo_Theme_Astrid/</id>
    <published>2017-03-06T07:30:14.000Z</published>
    <updated>2018-03-16T11:02:46.732Z</updated>
    
    <content type="html"><![CDATA[<p>从<code>WordPress</code>上移植的一款主题，托管于 <a href="https://github.com/Levance/hexo-theme-astrid" target="_blank" rel="noopener">GitHub</a> ，访问 <a href="http://blog.floretten.com/hexo-theme-astrid/">Astrid</a> 可进行预览。</p><a id="more"></a><h2 id="主题预览"><a href="#主题预览" class="headerlink" title="主题预览"></a>主题预览</h2><p><img src="http://floretten-1252347631.costj.myqcloud.com/astrid/preview-desktop.png" alt="Desktop Preview"></p><h2 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/Laueray/hexo-theme-astrid.git themes/astrid</span></span><br></pre></td></tr></table></figure><p>  详情请访问 <a href="https://github.com/Laueray/hexo-theme-astrid" target="_blank" rel="noopener">hexo-theme-astrid</a></p><h2 id="主题特性"><a href="#主题特性" class="headerlink" title="主题特性"></a>主题特性</h2><h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><p>Astrid 主题在非文章详情页提供 6 种挂件，这些挂件默认都展示，可在配置文件中通过注释来决定是否展示。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">recent_posts</span><span class="comment">#最近文章</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">social</span><span class="comment">#社交链接，可自行修改</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">archive</span><span class="comment">#文章归档</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">tagcloud</span><span class="comment">#标签云</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">category</span><span class="comment">#文章分类</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">recent_comments</span><span class="comment">#最近评论</span></span><br></pre></td></tr></table></figure><p>另外，Astrid 主题在文章详情页侧边栏可展示文章目录，效果如图。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/astrid/toc.png" alt="toc"></p><h3 id="动态云标签"><a href="#动态云标签" class="headerlink" title="动态云标签"></a>动态云标签</h3><p>Astrid 主题使用动态云标签，这样可解决标签数量过多占据大量页面的问题，当然可以选择不显示标签挂件。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/astrid/tagcloud.gif" alt="tagcloud"></p><h3 id="文章图片"><a href="#文章图片" class="headerlink" title="文章图片"></a>文章图片</h3><p><strong>Astrid</strong> 主题使用 <a href="https://sachinchoolur.github.io/lightgallery.js/" target="_blank" rel="noopener">lightgallery.js</a> 展示图片，效果如图。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/astrid/lightgallery.png" alt="lightgallery"></p><h3 id="文章版权声明"><a href="#文章版权声明" class="headerlink" title="文章版权声明"></a>文章版权声明</h3><p>Astrid 在文章末尾添加有关文章版权信息的声明，声明内容可在<code>layout/_partial/post/copyright.ejs</code>文件中自行定制,效果如图。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/astrid/copyright.png" alt="copyright"></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>Astrid 主题完成不久，尚有很多不足之处，望多多指正。另外该主题移植于 Astrid ，此处向原作者致谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从&lt;code&gt;WordPress&lt;/code&gt;上移植的一款主题，托管于 &lt;a href=&quot;https://github.com/Levance/hexo-theme-astrid&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt; ，访问 &lt;a href=&quot;http://blog.floretten.com/hexo-theme-astrid/&quot;&gt;Astrid&lt;/a&gt; 可进行预览。&lt;/p&gt;
    
    </summary>
    
      <category term="HEXO博客" scheme="http://blog.floretten.com/categories/HEXO%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Astrid" scheme="http://blog.floretten.com/tags/Astrid/"/>
    
  </entry>
  
  <entry>
    <title>使用 flow.ci 自动部署 Hexo</title>
    <link href="http://blog.floretten.com/2016/Flow_CI_Hexo/"/>
    <id>http://blog.floretten.com/2016/Flow_CI_Hexo/</id>
    <published>2016-11-19T07:53:14.000Z</published>
    <updated>2018-03-08T06:21:57.782Z</updated>
    
    <content type="html"><![CDATA[<p>国内持续集成工具<code>flow.ci</code>上线，尝试将其用于<code>Coding.net</code>仓库代码的构建与测试。</p><h2 id="认识-flow-ci"><a href="#认识-flow-ci" class="headerlink" title="认识 flow.ci"></a>认识 flow.ci</h2><hr><p><a href="http://flow.ci/" target="_blank" rel="noopener">flow.ci</a> 采用工作流机制，功能与 Travis CI 差不多，被称为国内的 Travis CI。</p><blockquote><p>融入 Workflow 机制的持续集成，让代码在 Build, Test, Deploy 间轻盈灵动</p></blockquote><p>关于 flow.ci 的更多介绍，可以访问其<a href="http://blog.flow.ci/" target="_blank" rel="noopener">官方博客</a>。</p><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><hr><p>关于使用 flow.ci 自动部署 Hexo 的方法，网上目前只在 Juglans’ Blog 中出现过。而作者提供的方法要把 id_rsa 文件放在博客源码中，如果使用 public 库，此法并不推荐。因为个人网站是双线托管，只拥有 GitHub public，于是要尝试新方法。</p><h3 id="注册-flow-ci"><a href="#注册-flow-ci" class="headerlink" title="注册 flow.ci"></a>注册 flow.ci</h3><p>必要步骤，有兴趣可以去 flow.ci 官网申请内测以获取邀请码。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/flow.ci/flow.ci001.png" alt="flow.ci"></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在 flow.ci 拉取仓库源码，创建相应的项目进行自动部署，flow.ci de工作流机制让操作变得简单。</p><p>具体的按照下面的顺序操作即可：<br>创建项目 -&gt; 选择代码源 -&gt; 选择用户 -&gt; 选择仓库 -&gt; 创建工作流 -&gt; 选择脚本模板。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/flow.ci/flow.ci003.png" alt="选择模板"></p><h3 id="设置触发器"><a href="#设置触发器" class="headerlink" title="设置触发器"></a>设置触发器</h3><p>设置自动部署触发器，因为我是把源代码放在放在分支 hexo 中，博客静态文件放在分支 master 中，所以我选设置为 push hexo 时触发。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/flow.ci/flow.ci004.png" alt="触发器"></p><h3 id="配置工作流"><a href="#配置工作流" class="headerlink" title="配置工作流"></a>配置工作流</h3><p>配置工作流，这里我们把 <code>测试</code> 部分删掉，然后加上 <code>自定义脚本</code>。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/flow.ci/flow.ci005.png" alt="自定义脚本"></p><p>脚本参考代码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装Hexo命令行工具</span></span><br><span class="line">flow_cmd <span class="string">"npm install hexo-cli -g"</span> --<span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行Hexo生成</span></span><br><span class="line">flow_cmd <span class="string">"hexo clean"</span> --<span class="built_in">echo</span></span><br><span class="line">flow_cmd <span class="string">"hexo g"</span> --<span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行Hexo推送，这里没有使用 hexo d，因为没有权限</span></span><br><span class="line">flow_cmd <span class="string">"cd ./public"</span> --<span class="built_in">echo</span></span><br><span class="line">flow_cmd <span class="string">"git init"</span> --<span class="built_in">echo</span></span><br><span class="line">flow_cmd <span class="string">"git config user.name "</span>your name<span class="string">" "</span> --<span class="built_in">echo</span>  <span class="comment">#修改name</span></span><br><span class="line">flow_cmd <span class="string">"git config user.email "</span>your email<span class="string">" "</span> --<span class="built_in">echo</span>  <span class="comment">#修改email</span></span><br><span class="line">flow_cmd <span class="string">"git add ."</span> --<span class="built_in">echo</span></span><br><span class="line">flow_cmd <span class="string">"git commit -m "</span>site update<span class="string">" "</span> --<span class="built_in">echo</span></span><br><span class="line">flow_cmd <span class="string">"git push --force --quiet "</span>git@git.coding.net:your name/reponame.git<span class="string">" master:master"</span> --<span class="built_in">echo</span> <span class="comment"># 修改repo</span></span><br></pre></td></tr></table></figure><h3 id="配置-Token"><a href="#配置-Token" class="headerlink" title="配置 Token"></a>配置 Token</h3><p>我们创建项目后，flow.ci 会自动在 Coding.net 中添加部署公钥，但是这个公钥只有只读权限，用于拉取（git clone）仓库代码，并没有推送权限。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/flow.ci/flow.ci006.png" alt="flow.ci"></p><p>所以现在我们把它删除，重新添加这个公钥，并勾选<code>推送功能</code>，这样这个公钥就拥有了推送回 Coding.net 的权限了，提高了安全性。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/flow.ci/flow.ci007.png" alt="coding.net"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>配置完后可以手动创建来测试一下是否成功，如不成功可以查看构建日志来查找不成功的原因。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/flow.ci/flow.ci008.png" alt="手动创建"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr><p>本文所提供自动部署 Hexo 方法解决了代码库安全性问题。如此便可专注于写好文章，构建部署就全交给 flow.ci 完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;国内持续集成工具&lt;code&gt;flow.ci&lt;/code&gt;上线，尝试将其用于&lt;code&gt;Coding.net&lt;/code&gt;仓库代码的构建与测试。&lt;/p&gt;
&lt;h2 id=&quot;认识-flow-ci&quot;&gt;&lt;a href=&quot;#认识-flow-ci&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="HEXO博客" scheme="http://blog.floretten.com/categories/HEXO%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://blog.floretten.com/tags/Hexo/"/>
    
      <category term="flow.ci" scheme="http://blog.floretten.com/tags/flow-ci/"/>
    
  </entry>
  
  <entry>
    <title>空数据段引发的问题及思考</title>
    <link href="http://blog.floretten.com/2016/Something_About_Data_Segment/"/>
    <id>http://blog.floretten.com/2016/Something_About_Data_Segment/</id>
    <published>2016-11-11T08:30:14.000Z</published>
    <updated>2018-01-30T12:37:03.613Z</updated>
    
    <content type="html"><![CDATA[<p>之前使用<code>Dosbox</code>环境编写汇编程序遇到的一个问题，经过摸索已基本搞清楚原因。</p><a id="more"></a><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><hr><p>原题目很简单，就是将 00F~0FH 共 16 个数字写入内存 3000H 开始的连续 16 个存储单元，但是我当时很纳闷为什么要写在 3000H 开始的内存中，于是就直接写在 0000H 开始的内存单元中，而且为了省事把前一个代码的数据段、代码段定义部分直接搬过来，但是写完后发现数据段并没有用到，心想也没有什么影响，就没有管它，然后就出错了。</p><p><strong>代码如下：</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DATA <span class="meta">SEGMENT</span></span><br><span class="line"></span><br><span class="line">DATA ENDS</span><br><span class="line">CODE <span class="meta">SEGMENT</span></span><br><span class="line">        <span class="meta">ASSUME</span> <span class="built_in">CS</span>:CODE, <span class="built_in">DS</span>:DATA</span><br><span class="line"><span class="symbol">START:</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">AX</span>,DATA</span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">DS</span>,<span class="built_in">AX</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">DI</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">CX</span>,<span class="number">16</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">AL</span>,<span class="number">0</span></span><br><span class="line"><span class="symbol">CWRITE:</span></span><br><span class="line">        <span class="keyword">MOV</span> [<span class="built_in">DI</span>],<span class="built_in">AL</span></span><br><span class="line">        <span class="keyword">INC</span> <span class="built_in">AL</span></span><br><span class="line">        <span class="keyword">INC</span> <span class="built_in">DI</span></span><br><span class="line">        <span class="keyword">LOOP</span> CWRITE</span><br><span class="line"><span class="symbol">EXIT:</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="number">AH</span>,<span class="number">4CH</span></span><br><span class="line">        <span class="keyword">INT</span> <span class="number">21H</span></span><br><span class="line">CODE ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure><h2 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h2><hr><p><strong>出错结果：</strong></p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Assembly/DosBox001.png" alt="errorview"></p><p>程序运行结束时 <code>CX=0002</code>，也就是说循环 <code>LOOP</code> 提前退出，这很奇怪！！！</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Assembly/DosBox002.png" alt="errorview"></p><p>而且我们查看当前内存单元的内容发现，我们的数据并没有正确写入，最后两个数据是不正确的。</p><h2 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h2><hr><p>为了搞清楚问题出在哪，接下来进行单步调试，来一步一步看程序是如何执行的，尤其看一下 <code>CX=0002</code> 时，程序究竟在干嘛！！！</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Assembly/DosBox003.png" alt="trackview"></p><p>单步执行开始，此时 <code>CX=000F</code>，继续向下，中间部分都符合程序正常逻辑。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Assembly/DosBox004.png" alt="trackview"></p><p>现在来到 <code>CX=0002</code>，往下应该是继续执行循环体，<strong>但是</strong>，问题出现了！！！</p><ol><li>首先，冒出了一句程序中没有的代码 <code>OR AX, 05FE</code>，并且发现<code>05FE</code> 就是之前查看内存时，被错误写入的那两个数据；</li><li>接着看一下这条指令在内存中的位置 <code>076A:000D</code> ，单步调试开始的时候，<code>076A:000D</code> 中的指令是 <code>MOV [DI], AL</code>。也就是说，当执行若干次循环到 <code>CX=0002</code> 的时候，该内存单元的内容被修改；</li><li>最后来看这块连续内存(000D-000F)中存储的内容，此时这块内存中内容为 <code>OD05FE</code>，而单步调试开始的时候，该连续内存中的内容是 <code>8805</code>。</li></ol><p>通过上述三点分析，已经不难发现，我们的程序在执行的后期被我们的数据修改了，数据从 <code>0000</code> 单元开始写入，当写到 <code>000D</code> 单元时，刚好碰到代码区，将原本的循环体内容覆盖，导致本该循环执行的指令出现差错，程序异常退出。<br>但是新的问题又出现了，数据段与代码段开始的地方为什么会离得这么近以至于出现如此近距离的冲突，我们做进一步探究…</p><h2 id="深入探究"><a href="#深入探究" class="headerlink" title="深入探究"></a>深入探究</h2><hr><p>在程序开始时我们看一下数据段与代码段在内存中的位置</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Assembly/DosBox005.png" alt="errorview"></p><p>程序开始前，数据段 <code>DS=075A</code>，代码段 <code>CS=076A</code>，两者相差 <code>100H</code>，即 256 个内存单元；然而当执行完装段操作(MOV DS, AX)后，数据段与代码段却变成一样的了(076A)，难怪会出现重叠。那么就是说我们定义的数据段和代码段是同一个位置开始的，那如果把数据段去掉结果会如何呢？</p><p><strong>代码如下：</strong></p><p>去掉 <code>DATA     SEGMENT</code> 的定义</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CODE <span class="meta">SEGMENT</span></span><br><span class="line">        <span class="meta">ASSUME</span> <span class="built_in">CS</span>:CODE</span><br><span class="line"><span class="symbol">START:</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">DI</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">CX</span>,<span class="number">16</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">AL</span>,<span class="number">0</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p><strong>结果展示：</strong></p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Assembly/DosBox006.png" alt="rightview"></p><p>去掉数据段之后，结果是正确的，只是这时数据是写在 <code>075A:0000</code> 开始的位置了。难道我们定义了数据段就会出现这样的问题，那么当年 Intel 的工程师们也太弱了吧，居然会出现这么严重的 Bug，但接下来的探究证明 Intel 毕竟是 Intel，不然 8086 也不会成为一代经典之作。</p><h2 id="进一步发现"><a href="#进一步发现" class="headerlink" title="进一步发现"></a>进一步发现</h2><hr><p>在之前的代码中虽然定义了数据段，但是并没有在其中定义数据，也就是说我们定义了一个空数据段，那么现在我们在数据段中定义一个数据，虽然我们不用它。</p><p><strong>代码如下：</strong><br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATA <span class="meta">SEGMENT</span></span><br><span class="line">        A <span class="built_in">DB</span> <span class="number">00H</span> <span class="comment">;定义数字</span></span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE <span class="meta">SEGMENT</span></span><br><span class="line">        <span class="meta">ASSUME</span> <span class="built_in">CS</span>:CODE, <span class="built_in">DS</span>:DATA</span><br><span class="line"><span class="symbol">START:</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">AX</span>,DATA</span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">DS</span>,<span class="built_in">AX</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">DI</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">CX</span>,<span class="number">16</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">AL</span>,<span class="number">0</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><p><strong>结果展示：</strong></p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Assembly/DosBox007.png" alt="rightview"></p><p>加上 <code>DATA     SEGMENT</code> 的定义，并且在其中定义变量之后，结果正确，那么看一下此时代码段与数据段的位置。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Assembly/DosBox008.png" alt="rightview"></p><p>此时，数据段 <code>DS=076A</code>，代码段 <code>CS=076B</code>，并且装段前后皆如此，他们之间相差 <code>10H</code>，即 16 个内存单元。这里我们只定义了一个字节型数据，系统默认为我们空出 16 个字节的，那么若是定义两个，三个会如何呢？<br>通过测试发现它是根据我们定义数据所占用内存单元的大小来为我们留出相应空间的，并且是以 16 个字节为一个单位，例如，当我们定义了 17 个字节型数据，它默认留出的空间是 32 个内存单元，当我们定义了 17 个字型数据，它默认留出的空间是 48 个内存单元，以此类推。</p><p>下面是定义了 17 个字节型数据的代码及演示结果。</p><p><strong>代码如下：</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATA <span class="meta">SEGMENT</span></span><br><span class="line">        A <span class="built_in">DB</span> <span class="number">17</span> DUP(<span class="number">00H</span>) <span class="comment">;定义数字</span></span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE <span class="meta">SEGMENT</span></span><br><span class="line">        <span class="meta">ASSUME</span> <span class="built_in">CS</span>:CODE, <span class="built_in">DS</span>:DATA</span><br><span class="line"><span class="symbol">START:</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">AX</span>,DATA</span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">DS</span>,<span class="built_in">AX</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">DI</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">CX</span>,<span class="number">16</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">AL</span>,<span class="number">0</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p><strong>结果展示：</strong></p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Assembly/DosBox009.png" alt="rightview"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr><p>血淋林的教训告诉我们没事别定义空数据段，然后把它晾在那，不然出现的问题会让人很意外！！！</p><p>以上便是本次编程经历的全部发现，如有问题或者类似的发现可一起交流探讨。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前使用&lt;code&gt;Dosbox&lt;/code&gt;环境编写汇编程序遇到的一个问题，经过摸索已基本搞清楚原因。&lt;/p&gt;
    
    </summary>
    
      <category term="汇编编程" scheme="http://blog.floretten.com/categories/%E6%B1%87%E7%BC%96%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="汇编" scheme="http://blog.floretten.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>8086 通用寄存器的专用功能</title>
    <link href="http://blog.floretten.com/2016/Register_of_8086/"/>
    <id>http://blog.floretten.com/2016/Register_of_8086/</id>
    <published>2016-11-09T02:31:14.000Z</published>
    <updated>2018-01-30T12:36:50.450Z</updated>
    
    <content type="html"><![CDATA[<p>根据汇编学习经历和编程经验总结一下8086系统通用寄存器的专用功能。</p><a id="more"></a><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><hr><p>8086 系统中有 8 个通用寄存器。虽然叫作通用寄存器，但它们却都有自己专门的名字，这是因为它们都有自己专门的功能。比如 CX 作为计数寄存器，用来存储循环次数。如果只有一个专用功能，那就它们只能称之为专用寄存器了，而这些寄存器还可以用来传送数据和暂存数据，所以称它们为通用寄存器。</p><h2 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h2><hr><p>数据寄存器主要用来保存操作数和运算结果等信息，它们的存在节省了为存取操作数所需占用总线和访问存储器的时间。这四个 16 位的数据寄存器均可分解成两个独立的 8 位寄存器，这些 8 位的寄存器有各自的名称，均可独立存取。<br>例如：AX寄存器可以分解为AH寄存器和 AL 寄存器，其中 AH 寄存器就是 AX 寄存器的高 8 位，AL 寄存器就是AX寄存器的低 8 位。其他寄存器类似。</p><h3 id="累积器"><a href="#累积器" class="headerlink" title="累积器"></a>累积器</h3><p><strong>AX</strong>:<br>i. 在字乘、字除指令中做累加器，存储被除数/商以及因数/积；<br>ii. 在字I/O操作时用做数据寄存器与外界设备传送数据；</p><p><strong>AH, AL</strong>:<br>i. 在LAHF指令中用做目的寄存器；<br>ii. 在字节乘、字节除指令中用做累加器，存储；<br>iii. 在字节I/O操作时做数据寄存器与外界设备传送数据；<br>iv. BCD、ASCII码数据运算时用作累加器，在XLAT指令中用作累加器。</p><p><strong>除法运算</strong><br>运算开始时：<br>如果除数是 8  位，被除数一定是 16 位的，被除数默认放在 AX 寄存器中；<br>如果除数是 16 位，被除数一定是 32 位的，这时要引入 DX，其中 DX 放被除数的高 16 位，AX 则放被除数的低 16 位。<br>运算结束时：<br>如果除数是 8  位，则 AL 中保存此次除法操作的商，而在 AH 中保存此次除法操作的余数；<br>如果除数是 16 位，则 AX 中保存此次除法操作的商，而在 DX 中保存此次除法操作的余数。</p><p><strong>乘法运算</strong><br>运算开始时：(两个相乘的数要么都是 8 位，要么都是 16 位)<br>如果两个相乘的数都是 8  位，则一个默认放在 AL 中，另一个放在 8  位寄存器中或者内存<strong>字节</strong>单元中；<br>如果两个相乘的数都是 16 位，则一个默认放在 AX 中，另一个放在 16 位寄存器中或者内存<strong>字  </strong>单元中。<br>运算结束时：<br>如果是 8  位的乘法运算，则默认乘法运算的结果是保存在 AX 中；<br>如果是 16 位的乘法运算，则默认乘法运算的结果有 32 位，这时要引入 DX，其中高位默认保存在 DX 中，而低位则默认保存在 AX 中。</p><h3 id="基址寄存器"><a href="#基址寄存器" class="headerlink" title="基址寄存器"></a>基址寄存器</h3><p><strong>BX</strong>:<br>i. 间接寻址时用作地址寄存器和基址寄存器；<br>ii. 在XLAT指令中用作基址寄存器。<br><strong>注</strong>：<br>它是四个数据存储器中唯一可以作为存储器指针使用的存储器</p><h3 id="计数寄存器"><a href="#计数寄存器" class="headerlink" title="计数寄存器"></a>计数寄存器</h3><p><strong>CX</strong>:<br>i. 字符串操作时用作循环次数计数器；<br>ii. 循环操作时用作循环次数计数器。</p><p><strong>CL</strong>:<br>在循环移位和移位操作时用作环移和移位次数的计数寄存器</p><p>CPU 在每次执行 LOOP 指令的时候，会完成两个过程：<br>i. CX = CX – 1，即令 CX 计数器自动减去 1；<br>ii. 判断 CX 中的值，如果 CX 中的值为 0 则会跳出循环，去执行循环后面的指令；如果 CX 中的值不为 0 ，则继续执行循环中所指定的指令。</p><h3 id="数据寄存器-1"><a href="#数据寄存器-1" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><p><strong>DX</strong>:<br>i. 在字乘、字除指令中用做辅助寄存器，具体使用见 AX 部分；<br>ii. I/O指令间接寻址时用作端口寄存器，存放I/O端口地址。</p><h2 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h2><hr><p>这两个 16 位寄存器只能按 16 位进行存取操作，主要用来形成操作数的地址，用于堆栈操作中计算操作数的有效地址。</p><h3 id="堆栈指针寄存器"><a href="#堆栈指针寄存器" class="headerlink" title="堆栈指针寄存器"></a>堆栈指针寄存器</h3><p><strong>SP</strong>:<br>堆栈指针，必须与SS配合使用，指向目前的堆栈位置，在任何时刻，SS:SP 都是指向栈顶元素。</p><h3 id="基址指针寄存器"><a href="#基址指针寄存器" class="headerlink" title="基址指针寄存器"></a>基址指针寄存器</h3><p><strong>BP</strong>:<br>i. 间接寻址时用作地址寄存器和变址寄存器；<br>ii. 用作 SS 的一个相对基址位置，用于给出堆栈中数据区基址的偏移，从而可以方便的实现直接存取堆栈中的数据。</p><p>如果指令中明确给出段地址，例如 DS:[BP]，那么它代表的内存单元是段地址为 DS，偏移量为 BP 寄存器中的值的内存单元；而如果指令中没有明确段地址，只使用 [BP] 时，那么它代表的内存单元是段地址为 SS，偏移量为 BP 寄存器中的值的内存单元。（BX，SI，DI 会默认使用 DS 段寄存器）</p><h2 id="变址寄存器"><a href="#变址寄存器" class="headerlink" title="变址寄存器"></a>变址寄存器</h2><hr><p>这两个16位寄存器只能按16位进行存取操作，主要用来形成操作数的地址，用于变址运算中计算操作数的有效地址。</p><h3 id="源地址寄存器"><a href="#源地址寄存器" class="headerlink" title="源地址寄存器"></a>源地址寄存器</h3><p><strong>SI</strong>:<br>i. 间接寻址时用作地址寄存器和变址寄存器；<br>ii. 串操作时时用作<strong>源</strong>变址寄存器，用来存放相对于 DS 段的<strong>源变址指针</strong>。</p><h3 id="目的地址寄存器"><a href="#目的地址寄存器" class="headerlink" title="目的地址寄存器"></a>目的地址寄存器</h3><p><strong>DI</strong>:<br>i. 间接寻址时用作地址寄存器和变址寄存器；<br>ii. 串操作时时用作<strong>目的</strong>变址寄存器，用来存放相对于 ES 段的<strong>目的变址指针</strong>。</p><p><strong>再次强调</strong>：<br>以上四个16位寄存器只能按16位进行存取操作，主要用来形成操作数的地址，用于堆栈操作和变址运算中计算操作数的有效地址。</p><h2 id="最后补充"><a href="#最后补充" class="headerlink" title="最后补充"></a>最后补充</h2><hr><p>除上述的专用功能外，在中断系统中相应功能的实现也会指定专用的寄存器，由于中断类型太多不一一列举，详情可以在网上搜索<strong>BIOS、DOS中断大全</strong>便可找到所有的功能实现。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Assembly/int21h.png" alt="INT21H"></p><p>完整 INT21H 功能可参考 <a href="http://wenku.baidu.com/link?url=SIa3cwuKcvxXclwPsgohSyBEKJQn3nRL3msqEo8_vu3ZxubIhBXeqYFqASuGcHmcf_Ca_Ami4_4Lm6eR0Ie0blJHuo0U644a7y-GldyHn9C" target="_blank" rel="noopener">百度文库</a> 或者自行搜索</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据汇编学习经历和编程经验总结一下8086系统通用寄存器的专用功能。&lt;/p&gt;
    
    </summary>
    
      <category term="汇编编程" scheme="http://blog.floretten.com/categories/%E6%B1%87%E7%BC%96%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="汇编" scheme="http://blog.floretten.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言实现进制转换</title>
    <link href="http://blog.floretten.com/2016/Conversion/"/>
    <id>http://blog.floretten.com/2016/Conversion/</id>
    <published>2016-11-05T05:30:35.000Z</published>
    <updated>2018-01-30T12:39:41.129Z</updated>
    
    <content type="html"><![CDATA[<p>汇编语言子程序大的设计与使用，实现十六进制显示输出寄存器中二进制内容。</p><a id="more"></a><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>编制一个过程把AL寄存器内的二进制数用十六进制的形式在屏幕上显示出来。</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>我们知道计算机里存储的是二进制，但显示的时候是通过转换成ASCII码显示出来的，所以我们要做的就是把这些二进制数每四位一组转换成对应数字的ASCII码值并将其赋值给DL，调用21H中断将其显示输出即可。具体的转换过程可以参考代码注释部分。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">DATA<span class="meta">SEGMENT</span></span><br><span class="line">        COUNT  <span class="built_in">EQU</span>  <span class="number">5</span></span><br><span class="line">        ARRAY  <span class="built_in">DB</span>  <span class="number">12H</span>, <span class="number">34H</span>, <span class="number">24H</span>, <span class="number">86H</span>, <span class="number">47H</span></span><br><span class="line">DATAENDS</span><br><span class="line">CODE<span class="meta">SEGMENT</span></span><br><span class="line">        <span class="meta">ASSUME</span> <span class="built_in">CS</span>:CODE</span><br><span class="line"><span class="symbol">START:</span></span><br><span class="line">        <span class="keyword">MOV</span>  <span class="built_in">AX</span>, DATA</span><br><span class="line">        <span class="keyword">MOV</span>  <span class="built_in">DS</span>, <span class="built_in">AX</span></span><br><span class="line">        <span class="keyword">MOV</span>  <span class="built_in">BX</span>, OFFSET ARRAY</span><br><span class="line">        <span class="keyword">MOV</span>  <span class="built_in">CX</span>, COUNT</span><br><span class="line"><span class="symbol">DISPLP:</span></span><br><span class="line">        <span class="keyword">MOV</span>  <span class="built_in">AL</span>, [<span class="built_in">BX</span>]</span><br><span class="line">        <span class="keyword">CALL</span> ALDISP</span><br><span class="line">        <span class="keyword">MOV</span>  <span class="built_in">AL</span>, <span class="string">','</span><span class="comment">;逗号分隔，不过输出结果很让人意外</span></span><br><span class="line">        <span class="keyword">MOV</span>  <span class="number">AH</span>, <span class="number">02H</span></span><br><span class="line">        <span class="keyword">INT</span>  <span class="number">21H</span></span><br><span class="line">        <span class="keyword">INC</span>  <span class="built_in">BX</span></span><br><span class="line">        <span class="keyword">LOOP</span> DISPLP</span><br><span class="line"><span class="symbol">EXIT:</span></span><br><span class="line">        <span class="keyword">MOV</span>  <span class="number">AH</span>, <span class="number">4CH</span></span><br><span class="line">        <span class="keyword">INT</span>  <span class="number">21H</span></span><br><span class="line"></span><br><span class="line">ALDISPPROC<span class="comment">;实现AL内容的显示</span></span><br><span class="line">        <span class="keyword">PUSH</span> <span class="built_in">AX</span></span><br><span class="line">        <span class="keyword">PUSH</span> <span class="built_in">CX</span></span><br><span class="line">        <span class="keyword">PUSH</span> <span class="built_in">DX</span><span class="comment">;子程序使用到的寄存器压栈以保护</span></span><br><span class="line">        <span class="keyword">PUSH</span> <span class="built_in">AX</span><span class="comment">;暂存AX，稍后转换低四位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">MOV</span>  <span class="built_in">DL</span>, <span class="built_in">AL</span> <span class="comment">;转换AL高四位</span></span><br><span class="line">        <span class="keyword">MOV</span>  <span class="built_in">CL</span>, <span class="number">4</span><span class="comment">;(CL)=4(0000HHHH)</span></span><br><span class="line">        <span class="keyword">SHR</span>  <span class="built_in">DL</span>, <span class="built_in">CL</span><span class="comment">;(0-9)(30H-39H)(A-F)(41H-46H)</span></span><br><span class="line">        <span class="keyword">OR</span>   <span class="built_in">DL</span>, <span class="number">30H</span><span class="comment">;(0000HHHH)(00110000)高四位变成3</span></span><br><span class="line">        <span class="keyword">CMP</span>  <span class="built_in">DL</span>, <span class="number">39H</span></span><br><span class="line">        <span class="keyword">JBE</span>  ALDISP1<span class="comment">;显示数字(0-9)</span></span><br><span class="line">        <span class="keyword">ADD</span>  <span class="built_in">DL</span>, <span class="number">7</span><span class="comment">;显示数字(A-F)</span></span><br><span class="line"><span class="symbol">ALDISP1:</span></span><br><span class="line">        <span class="keyword">MOV</span>  <span class="number">AH</span>, <span class="number">02H</span></span><br><span class="line">        <span class="keyword">INT</span>  <span class="number">21H</span></span><br><span class="line">        <span class="keyword">POP</span>  <span class="built_in">DX</span><span class="comment">;恢复AX保存到DX</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">AND</span>  <span class="built_in">DL</span>, <span class="number">0FH</span><span class="comment">;转换AL低四位(HHHHLLLL)(00001111)</span></span><br><span class="line">        <span class="keyword">OR</span>   <span class="built_in">DL</span>, <span class="number">30H</span><span class="comment">;(0000LLLL)(00110000)高四位变成3</span></span><br><span class="line">        <span class="keyword">CMP</span>  <span class="built_in">DL</span>, <span class="number">39H</span></span><br><span class="line">        <span class="keyword">JBE</span>  ALDISP2</span><br><span class="line">        <span class="keyword">ADD</span>  <span class="built_in">DL</span>, <span class="number">7</span></span><br><span class="line"><span class="symbol">ALDISP2:</span></span><br><span class="line">        <span class="keyword">MOV</span>  <span class="number">AH</span>, <span class="number">02H</span></span><br><span class="line">        <span class="keyword">INT</span>  <span class="number">21H</span></span><br><span class="line">        <span class="keyword">POP</span>  <span class="built_in">DX</span></span><br><span class="line">        <span class="keyword">POP</span>  <span class="built_in">CX</span></span><br><span class="line">        <span class="keyword">POP</span>  <span class="built_in">AX</span></span><br><span class="line">        <span class="keyword">RET</span></span><br><span class="line">ALDISPENDP</span><br><span class="line"></span><br><span class="line">CODEENDS</span><br><span class="line">        END START</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="http://floretten-1252347631.costj.myqcloud.com/Assembly/exchange.png" alt="result"></p><p><strong>说明</strong>：代码中本来想用逗号分割的，结果输出的不知道是什么鬼，不过不影响功能的实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;汇编语言子程序大的设计与使用，实现十六进制显示输出寄存器中二进制内容。&lt;/p&gt;
    
    </summary>
    
      <category term="汇编编程" scheme="http://blog.floretten.com/categories/%E6%B1%87%E7%BC%96%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="汇编" scheme="http://blog.floretten.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言实现冒泡排序</title>
    <link href="http://blog.floretten.com/2016/BubbleSort_x86Assembly/"/>
    <id>http://blog.floretten.com/2016/BubbleSort_x86Assembly/</id>
    <published>2016-10-28T07:30:10.000Z</published>
    <updated>2018-01-30T12:40:59.820Z</updated>
    
    <content type="html"><![CDATA[<p>回顾最近所学知识，用汇编语言实现冒泡排序。</p><a id="more"></a><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><hr><p>数据区存放一组数据，要求采用冒泡法对数据区的数据按递增排序，并且从最后一位开始向前比较，排序完成后把数据按排序后的递增顺序放回。</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><hr><p>冒泡排序在高级语言中同时要使用双重循环，这里也不例外。因此一层一层的来。</p><p>先实现<strong>内层循环</strong>，即一个一个相邻的数进行比较，该调换顺序的调换顺序，不用调换的直接进行下一位比较，具体看代码中<strong>SORT..LOOP</strong>部分。</p><p>再实现<strong>外层循环</strong>，根据冒泡排序，每进行一次内层循环，就会有一个最小的数到达它该到达的位置，这样一来下一趟排序循环的次数就减一，于是在外层循环中我们就控制内层循环的次数<strong>(CX)</strong>，内层循环进行一次退出后，在外层循环将循环次数减一<strong>(DEC CX)</strong>再让其进入循环，直到循环次数为 0 <strong>(CMP CX, 0)</strong>退出。另外还有一个要保存的是每次循环开始的位置<strong>(PUSH SI)</strong>。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><hr><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">DATA <span class="meta">SEGMENT</span></span><br><span class="line">        ORG<span class="number">3000H</span></span><br><span class="line">        COUNT <span class="built_in">EQU</span> <span class="number">6</span></span><br><span class="line">        <span class="keyword">STR</span> <span class="built_in">DB</span> <span class="number">12H</span>, <span class="number">78H</span>, <span class="number">62H</span>, <span class="number">50H</span>, <span class="number">22H</span>, <span class="number">33H</span></span><br><span class="line">DATAENDS</span><br><span class="line">CODE<span class="meta">SEGMENT</span></span><br><span class="line">        <span class="meta">ASSUME</span> <span class="built_in">DS</span>:DATA, <span class="built_in">CS</span>:CODE</span><br><span class="line"><span class="symbol">START:</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">AX</span>, DATA</span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">DS</span>, <span class="built_in">AX</span><span class="comment">;装载段地址</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">SI</span>, OFFSET <span class="keyword">STR</span><span class="comment">;偏移地址</span></span><br><span class="line">        <span class="keyword">ADD</span> <span class="built_in">SI</span>, COUNT</span><br><span class="line">        <span class="keyword">DEC</span> <span class="built_in">SI</span><span class="comment">;跳到最后一个位置，这里是实验题目要求，不要奇怪博主为何从后往前比较</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">CX</span>, COUNT</span><br><span class="line"></span><br><span class="line"><span class="symbol">W:</span><span class="comment">;外层循环开始</span></span><br><span class="line">        <span class="keyword">PUSH</span> <span class="built_in">CX</span><span class="comment">;保存一趟排序要比较的次数，即循环次数，下一趟排序时减一</span></span><br><span class="line">        <span class="keyword">PUSH</span> <span class="built_in">SI</span><span class="comment">;保存一趟排序开始的位置，需要保持不变</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SORT:</span><span class="comment">;内层循环开始，一趟排序开始</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">BL</span>, [<span class="built_in">SI</span>]</span><br><span class="line">        <span class="keyword">CMP</span> <span class="built_in">BL</span>, [<span class="built_in">SI</span>-<span class="number">1</span>] <span class="comment">;当前位置与其下一个位置比较</span></span><br><span class="line">        <span class="keyword">JB</span>  A</span><br><span class="line">        <span class="keyword">JMP</span> B</span><br><span class="line"></span><br><span class="line"><span class="symbol">A:</span></span><br><span class="line">        <span class="keyword">XCHG</span> <span class="built_in">BL</span>, [<span class="built_in">SI</span>-<span class="number">1</span>] <span class="comment">;当前位置比下一位小，交换</span></span><br><span class="line">        <span class="keyword">MOV</span>  [<span class="built_in">SI</span>], <span class="built_in">BL</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">B:</span></span><br><span class="line">        <span class="keyword">DEC</span>  <span class="built_in">SI</span></span><br><span class="line">        <span class="keyword">LOOP</span> SORT<span class="comment">;内层循环结束，一趟排序结束</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">POP</span> <span class="built_in">SI</span><span class="comment">;恢复排序开始位置</span></span><br><span class="line">        <span class="keyword">POP</span> <span class="built_in">CX</span></span><br><span class="line">        <span class="keyword">DEC</span> <span class="built_in">CX</span><span class="comment">;下一趟循环，比较次数减一</span></span><br><span class="line">        <span class="keyword">CMP</span> <span class="built_in">CX</span>, <span class="number">0</span><span class="comment">;CX大于0，说明还需要继续冒泡</span></span><br><span class="line">        <span class="keyword">JA</span>  W</span><br><span class="line">        <span class="keyword">JMP</span> EXIT<span class="comment">;外层循环结束</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">EXIT:</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="number">AH</span>, <span class="number">4CH</span></span><br><span class="line">        <span class="keyword">INT</span> <span class="number">21H</span><span class="comment">;返回系统</span></span><br><span class="line"></span><br><span class="line">CODEENDS</span><br><span class="line">        END START</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回顾最近所学知识，用汇编语言实现冒泡排序。&lt;/p&gt;
    
    </summary>
    
      <category term="汇编编程" scheme="http://blog.floretten.com/categories/%E6%B1%87%E7%BC%96%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="汇编" scheme="http://blog.floretten.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="冒泡排序" scheme="http://blog.floretten.com/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>8086 指令系统寻址</title>
    <link href="http://blog.floretten.com/2016/Addressing_Mode_of_8086/"/>
    <id>http://blog.floretten.com/2016/Addressing_Mode_of_8086/</id>
    <published>2016-10-18T08:30:14.000Z</published>
    <updated>2018-02-28T04:26:36.422Z</updated>
    
    <content type="html"><![CDATA[<p>整理汇编语言学习笔记，回顾一下8086 指令系统的寻址方式。</p><a id="more"></a><h2 id="寻址与指令"><a href="#寻址与指令" class="headerlink" title="寻址与指令"></a>寻址与指令</h2><hr><blockquote><p>寻址方式（Addressing Mode）是确定<strong>当前指令操作数地址</strong>以及<strong>下一条要执行指令地址</strong>的方法。</p></blockquote><p>简单说就是在指令中操作数和下一条指令（地址）是如何获取的，是直接给出，还是给出提示信息去查找。</p><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><hr><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>操作数直接放在指令的操作数码段中，故立即寻址<strong>不会访问寄存器，存储器</strong>，指令执行速度快。</p><p>图形示意：</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Directive/directive002.png" alt="立即寻址"></p><p>代码示意：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov al, <span class="number">5</span>;执行结果：(al) = <span class="number">5</span>      [<span class="string">"()"</span>表示取内容，以下皆如此]</span><br></pre></td></tr></table></figure><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>操作数存放在寄存器中，而在指令中给出寄存器的标号，指令执行时会到这个寄存器中取出相应的操作数，即访问寄存器，不访问存储器，速度也很快。</p><p>图形示意：</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Directive/directive003.png" alt="寄存器寻址"></p><p>代码示意：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">bx</span><span class="comment">;假设(bx) = 30H，则执行结果为：(ax) = 30H</span></span><br></pre></td></tr></table></figure><h3 id="存储器寻址说明"><a href="#存储器寻址说明" class="headerlink" title="存储器寻址说明"></a>存储器寻址说明</h3><p><strong>1.有效地址</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有效地址（EA）= 位移量<span class="comment">(disp)</span> + 基址<span class="comment">(base)</span> + 变址<span class="comment">(index)</span></span><br></pre></td></tr></table></figure><p>位移量：存放在指令中的数，但它不是立即数，而是一个<code>地址</code>，可以用变量或标号表示。<br>基址：存放在基址寄存器(BX、BP)中，有效地址的基址部分。<br>变址：存放在变址寄存器(SI、DI)中，有效地址的变址部分。</p><p><strong>2.段前缀使用规则</strong></p><p>8086 允许程序员用段跨越前缀来改变系统所指定的默认段，如：允许数据存放在 DS 以外的段中，使用时指明段前缀，但是有些情况是不可以修改的。</p><p>(1) 串处理操作中<strong>目的串</strong>必须用 ES 段，即默认为 ES:DI，不可修改。<br>(2) <strong>压栈</strong>（push）、<strong>弹栈</strong>（pop）必须使用 SS 段，即默认为 SS:SP 不可修改。<br>(3) <strong>指令</strong>必须存放在 CS段 中。</p><table><thead><tr><th style="text-align:center">访存类型</th><th style="text-align:center">所用段及段寄存器</th><th style="text-align:center">缺省时使用规则</th></tr></thead><tbody><tr><td style="text-align:center">指针</td><td style="text-align:center">代码段 CS</td><td style="text-align:center">取指</td></tr><tr><td style="text-align:center">堆栈</td><td style="text-align:center">堆栈段 SS</td><td style="text-align:center">所有的堆栈操作/任何用 BP 作为基址寄存器的访存</td></tr><tr><td style="text-align:center">局部数据</td><td style="text-align:center">数据段 DS</td><td style="text-align:center">除堆栈以及串处理操作中目的串以外的数据访问</td></tr><tr><td style="text-align:center">目的串</td><td style="text-align:center">附加段 ES</td><td style="text-align:center">串处理操作中的目的串</td></tr></tbody></table><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>操作数的有效地址只包含位移量一种成分，有效地址 = 位移量 ，而位移量就存放在指令的操作数码段中。<br><strong>注意</strong>：<br>1、为了防止指令字过长，规定双操作数指令中的两个操作数中，只能有一个使用存储器寻址方式。<br>2、注意区分有效地址别称 — <strong>偏移地址</strong>（Offset Address）与<strong>位移量</strong>（displacement），这是两个概念。</p><p>图形示意：</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Directive/directive004.png" alt="直接寻址"></p><p>代码示意：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [<span class="number">2000</span>H];假设 (ds) = <span class="number">3000</span>H ，则执行结果为：(ax) = (<span class="number">32000</span>) ，即取出存储单元 <span class="number">32000</span>H<span class="number">-32001</span>H 位置的值赋给 ax</span><br></pre></td></tr></table></figure><p>位移量可以像高级语言一样用变量表示，而且还可以为这个位移量指定段前缀。</p><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>操作数在存储器中，而其有效地址存放在某个寄存器中，可用寄存器有 BX、BP、SI、DI。</p><p>区别于寄存器寻址，前者操作数存放在寄存器中，在指令中存放相应的寄存器号码，不需要访存；后者的寄存器存放操作数的有效地址，而操作数本身在存储器中。指令要先通过该寄存器获取操作数有效地址，在通过该地址访存获取操作数。<br>同样也可以为其指定其他段前缀。</p><p>图形示意：</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Directive/directive005.png" alt="寄存器间接寻址"></p><p>代码示意：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax，[bx];假设 (ds) = <span class="number">2000</span>H，(bx) = <span class="number">1000</span>H ，则执行结果为：(ax) = (<span class="number">21000</span>) ，即取出存储单元 <span class="number">21000</span>H<span class="number">-21001</span>H 位置的值赋给 ax</span><br></pre></td></tr></table></figure><h3 id="寄存器相对寻址"><a href="#寄存器相对寻址" class="headerlink" title="寄存器相对寻址"></a>寄存器相对寻址</h3><p>操作数有效地址等于寄存器内容与指令中指定位移量之和，可使用寄存器有 BX、BP、SI、DI。与寄存器间接寻址相比，指令中多了位移量。</p><p>有效地址（EA）= 基址/变址 + 位移量。</p><p>图形示意：</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Directive/directive006.png" alt="寄存器相对寻址"></p><p>代码示意：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, count[si]/[count+si];假设 (ds) = <span class="number">3000</span>H ，(si) = <span class="number">2000</span>H ，count = <span class="number">3000</span>H ，则执行结果为：(ax) = (<span class="number">35000</span>H)，即取出存储单元 <span class="number">35000</span>H<span class="number">-35001</span>H 位置的值赋给 ax</span><br></pre></td></tr></table></figure><h3 id="基址变址寻址"><a href="#基址变址寻址" class="headerlink" title="基址变址寻址"></a>基址变址寻址</h3><p>操作数有效地址等于基址寄存器与变址寄存器内容之和，可使用寄存器有 BX、BP、SI、DI。</p><p>有效地址（EA）= 基址 + 变址。</p><p>图形示意：</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Directive/directive007.png" alt="基址变址寻址"></p><p>代码示意：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [<span class="string">bx</span>][<span class="symbol">di</span>]/[bx+di];假设 (ds) = 2100H ，(bx) = 0158H ，(di) = 10A5H ，则执行结果为：(ax) = (221FDH)，即取出存储单元 221FDH-221FEH 位置的值赋给 ax</span><br></pre></td></tr></table></figure><h3 id="相对基址变址寻址"><a href="#相对基址变址寻址" class="headerlink" title="相对基址变址寻址"></a>相对基址变址寻址</h3><p>操作数有效地址是基址寄存器与变址寄存器的内容和指令中指定的位移量之和。相比前面多了位移量，而寻址方式命名中多了相对二字。</p><p>有效地址（EA）= 基址 + 变址 + 位移量</p><p><strong>总结</strong>：<br>(1) 只有<strong>位移量</strong>一项时叫<strong>直接寻址</strong>，除位移量外，还有其他项的叫做<strong>相对XX寻址/XX相对寻址</strong>。<br>(2) 存储器寻址可以使用的寄存器只有四个，因为要存放的都是地址。</p><p>图形示意：</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Directive/directive008.png" alt="相对基址变址寻址"></p><p>代码示意：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, count[<span class="string">bx</span>][<span class="symbol">si</span>]/[count+bx+si];假设 (ds) = 3000H ，(bx) = 2000H ，(si) = 1000H ，count = 0250H ，则执行结果为：(ax) = (33250H)，即取出存储单元 33250H-33251H 位置的值赋给 ax</span><br></pre></td></tr></table></figure><p><strong>应用</strong>：<br>这种寻址方式通常用于对二维数组的寻址。也为堆栈处理提供了方便，一般(BP)可指向栈顶，从栈顶到数组的首地址可用位移量表示，变址寄存器可用来访问数组中的某个元素。</p><h2 id="转移寻址"><a href="#转移寻址" class="headerlink" title="转移寻址"></a>转移寻址</h2><hr><p><strong>段内与段间</strong>：两者区别就在于地址跳转时是否跨越当前段范围，段内就是不跨越，相应的段跨越前缀就不用修改，只需要修改偏移量；段间需要跨越段范围，段跨越前缀要和偏移量同时修改。</p><p><strong>直接与间接</strong>：前者指直接给出即将跳转地址与当前地址（段跨越前缀的偏移和有效地址的偏移）之差，而后者需要通过像数据相关寻址一样间接获取这个差值。</p><h3 id="段内直接寻址"><a href="#段内直接寻址" class="headerlink" title="段内直接寻址"></a>段内直接寻址</h3><p>转向的有效地址是当前IP寄存器的内容和指令中指定的8位或16位位移量之和，所以它是一种相对寻址方式。<br>指令中的位移量是转向的有效地址与当前 IP 值之差，所以当这一程序段在内存中的不同区域运行时，这种寻址方式的转移指令本身不会发生变化，这是符合程序的再定位要求的。</p><p>图形示意：</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Directive/directive009.png" alt="段内直接寻址"></p><p>代码示意：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> <span class="built_in">near</span> <span class="built_in">ptr</span> progia</span><br><span class="line"><span class="keyword">jmp</span> short quest</span><br></pre></td></tr></table></figure><p>其中，progia和quest均为转向的符号地址，在机器指令中，用位移量来表示。<br>在汇编指令中，如果位移量为16位，则在符号地址前加操作符near ptr，如果位移量为8位，则在符号地址前加操作符SHORT。<br>条件转移指令只能使用段内直接寻址的8位位移量。</p><h3 id="段内间接寻址"><a href="#段内间接寻址" class="headerlink" title="段内间接寻址"></a>段内间接寻址</h3><p>转向有效地址是一个寄存器或存储单元的内容。(这个寄存器或存储单元的内容可以用数据寻址方式中除立即数以外的任何一种寻址方式取得)，所得到的转向的有效地址用来取代IP寄存器的内容。</p><p>图形示意：</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Directive/directive010.png" alt="段内间接寻址"></p><p>代码示意：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">jmp</span> <span class="built_in">word</span> <span class="built_in">ptr</span>[<span class="built_in">bp</span>+table]</span><br></pre></td></tr></table></figure><h3 id="段间直接寻址"><a href="#段间直接寻址" class="headerlink" title="段间直接寻址"></a>段间直接寻址</h3><p>在指令中直接提供了转向段地址和偏移地址，所以只要用指令中指定的偏移地址取代IP寄存器的内容，用指令中指定的段地址取代CS寄存器的内容就完成了从一个段到另一个段的转移操作。</p><p>图形示意：</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Directive/directive011.png" alt="段间直接寻址"></p><p>代码示意：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> <span class="built_in">far</span> <span class="built_in">ptr</span> next<span class="comment">;next 为转向的符号地址，far ptr 则是表示段间转移的操作符。</span></span><br></pre></td></tr></table></figure><h3 id="段间间接寻址"><a href="#段间间接寻址" class="headerlink" title="段间间接寻址"></a>段间间接寻址</h3><p>用存储器中的两个相继字的内容来取代IP和CS寄存器中的原始内容，以达到段间转移的目的。(这里，存储单元的地址是由指令指定除立即数方式和寄存器方式以外的任何一种数据寻址方式取得)</p><p>图形示意：</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Directive/directive012.png" alt="段间间接寻址"></p><p>代码示意：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">jmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span>[inters+<span class="built_in">bx</span>]</span><br></pre></td></tr></table></figure><p>其中，[inters+bx]说明数据寻址方式为寄存器相对寻址方式，dword ptr为双字操作符，说明转向地址需取双字为段间转移指令。依次作为IP和CS的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理汇编语言学习笔记，回顾一下8086 指令系统的寻址方式。&lt;/p&gt;
    
    </summary>
    
      <category term="汇编编程" scheme="http://blog.floretten.com/categories/%E6%B1%87%E7%BC%96%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="汇编" scheme="http://blog.floretten.com/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text 设置与常用插件</title>
    <link href="http://blog.floretten.com/2016/Sublime_Text_Settings_Plugins/"/>
    <id>http://blog.floretten.com/2016/Sublime_Text_Settings_Plugins/</id>
    <published>2016-10-05T08:30:14.000Z</published>
    <updated>2017-10-06T04:34:33.465Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Sublime 已有好几年了，在此分享使用 Sublime 的相关设置及常用插件。</p><a id="more"></a><h2 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h2><p>Sublime Text 只是一个代码编辑器，而不是集成开发环境（IDE）。</p><blockquote><p>Sublime Text 是一个跨平台的编辑器，同时支持Windows、Linux、Mac OS X等操作系统。</p></blockquote><h2 id="Sublime-设置"><a href="#Sublime-设置" class="headerlink" title="Sublime 设置"></a>Sublime 设置</h2><p>Sublime Text 跟很多优秀的代码编辑器一样，并不是通过图形界面来进行设置的，而是根据一行行代码实现的。</p><p>以下为 Sublime Settings 的中文版详细内容</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置文本区域颜色主题</span></span><br><span class="line">    <span class="string">"color_scheme"</span>: <span class="string">"Packages/Color Scheme – Default/Monokai.tmTheme"</span>,</span><br><span class="line">    <span class="comment">// 设置字体和大小</span></span><br><span class="line">    <span class="string">"font_face"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="string">"font_size"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="comment">// 有效选项有：no_bold不显示粗体字，no_italic不显示斜体字，no_antialias关闭反锯齿，gray_antialias开启反锯齿</span></span><br><span class="line">    <span class="comment">// subpixel_antialias和no_round是OS X系统独有的，gdi和directwrite是windows系统独有的</span></span><br><span class="line">    <span class="string">"font_options"</span>: [],</span><br><span class="line">    <span class="comment">// 在文字上双击会全选当前的内容，如果里面出现以下字符，就会被截断</span></span><br><span class="line">    <span class="string">"word_separators"</span>: <span class="string">"./\\()\"'-:,.;&lt;&gt;~!@#$%^&amp;*|+=[]&#123;&#125;`~?"</span>,</span><br><span class="line">    <span class="comment">// 是否显示行号</span></span><br><span class="line">    <span class="string">"line_numbers"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否显示行号边栏</span></span><br><span class="line">    <span class="string">"gutter"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 行号边栏和文字的间距</span></span><br><span class="line">    <span class="string">"margin"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="comment">// 是否显示代码折叠按钮</span></span><br><span class="line">    <span class="string">"fold_buttons"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 除非鼠标悬停行号边栏，否则代码折叠按钮将隐藏</span></span><br><span class="line">    <span class="string">"fade_fold_buttons"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 列显示垂直标尺，在中括号里填入数字，宽度按字符计算</span></span><br><span class="line">    <span class="string">"rulers"</span>: [],</span><br><span class="line">    <span class="comment">// 是否打开拼写检查</span></span><br><span class="line">    <span class="string">"spell_check"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// Tab键制表符宽度</span></span><br><span class="line">    <span class="string">"tab_size"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="comment">// 设为true时，缩进和遇到Tab键时使用空格替代</span></span><br><span class="line">    <span class="string">"translate_tabs_to_spaces"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 否则作用于单个空格</span></span><br><span class="line">    <span class="string">"use_tab_stops"</span>: <span class="literal">true</span>,</span><br><span class="line">     <span class="comment">// false时禁止在载入的时候检测制表符和空格</span></span><br><span class="line">    <span class="string">"detect_indentation"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 按回车时，自动与制表位对齐</span></span><br><span class="line">    <span class="string">"auto_indent"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//针对C语言的</span></span><br><span class="line">    <span class="string">"smart_indent"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 需要启用auto_indent</span></span><br><span class="line">    <span class="string">"indent_to_bracket"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 显示对齐的白线是否根据回车、tab等操作自动填补</span></span><br><span class="line">    <span class="string">"trim_automatic_white_space"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否自动换行，如果选auto，需要加双引号</span></span><br><span class="line">    <span class="string">"word_wrap"</span>: <span class="keyword">auto</span>,</span><br><span class="line">    <span class="comment">// 设置窗口内文字区域的宽度</span></span><br><span class="line">    <span class="string">"wrap_width"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 防止被缩进到同一级的字换行</span></span><br><span class="line">    <span class="string">"indent_subsequent_lines"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 如果没有定义过，则文件居中显示</span></span><br><span class="line">    <span class="string">"draw_centered"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 自动匹配引号，括号等</span></span><br><span class="line">    <span class="string">"auto_match_enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 拼写检查的单词列表路径</span></span><br><span class="line">    <span class="string">"dictionary"</span>: <span class="string">"Packages/Language – English/en_US.dic"</span>,</span><br><span class="line">    <span class="string">"spelling_selector"</span>: <span class="string">"markup.raw, source string.quoted - punctuation - meta.preprocessor.c.include, source comment - source comment.block.preprocessor, -(source, constant, keyword, storage, support, variable, markup.underline.link, meta.tag)"</span>,</span><br><span class="line">    <span class="comment">// 代码地图的可视区域部分是否加上边框，边框的颜色可在配色方案上加入minimapBorder键</span></span><br><span class="line">    <span class="string">"draw_minimap_border"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否一直显示代码地图框</span></span><br><span class="line">    <span class="string">"always_show_minimap_viewport"</span>: <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 突出显示当前光标所在的行</span></span><br><span class="line">    <span class="string">"highlight_line"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 设置光标闪动方式</span></span><br><span class="line">    <span class="string">"caret_style"</span>: <span class="string">"smooth"</span>,</span><br><span class="line">    <span class="comment">// 设置光标的尺寸</span></span><br><span class="line">    <span class="string">"caret_extra_top"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"caret_extra_bottom"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"caret_extra_width"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 是否特殊显示当前光标所在的括号、代码头尾闭合标记</span></span><br><span class="line">    <span class="string">"match_brackets"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 设为false时，只有光标在括号或头尾闭合标记的两端时，match_brackets才生效</span></span><br><span class="line">    <span class="string">"match_brackets_content"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否突出显示圆括号，match_brackets为true生效</span></span><br><span class="line">    <span class="string">"match_brackets_square"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否突出显示大括号，match_brackets为true生效</span></span><br><span class="line">    <span class="string">"match_brackets_braces"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否突出显示尖括号，match_brackets为true生效</span></span><br><span class="line">    <span class="string">"match_brackets_angle"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// html和xml下突出显示光标所在标签的两端，影响HTML、XML、CSS等</span></span><br><span class="line">    <span class="string">"match_tags"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 全文突出显示和当前选中字符相同的字符</span></span><br><span class="line">    <span class="string">"match_selection"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 设置每一行到顶部，以像素为单位的间距，效果相当于行距</span></span><br><span class="line">    <span class="string">"line_padding_top"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 设置每一行到底部，以像素为单位的间距，效果相当于行距</span></span><br><span class="line">    <span class="string">"line_padding_bottom"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 设置为false时，滚动到文本的最下方时，没有缓冲区</span></span><br><span class="line">    <span class="string">"scroll_past_end"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 控制向上或向下到第一行或最后一行时发生什么</span></span><br><span class="line">    <span class="string">"move_to_limit_on_up_down"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 按space或tab时，实际会产生白色的点（一个空格一个点）或白色的横线（tab_size设置的制表符的宽度），选中状态下才能看到</span></span><br><span class="line">    <span class="comment">// 设置为none时，什么情况下都不显示这些点和线</span></span><br><span class="line">    <span class="comment">// 设置为selection时，只显示选中状态下的点和线</span></span><br><span class="line">    <span class="comment">// 设置为all时，则一直显示</span></span><br><span class="line">    <span class="string">"draw_white_space"</span>: <span class="string">"selection"</span>,</span><br><span class="line">    <span class="comment">// 制表位的对齐白线是否显示，颜色可在主题文件里设置（guide，activeGuide，stackGuide）</span></span><br><span class="line">    <span class="string">"draw_indent_guides"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 制表位的对齐白线，draw_normal为一直显示，draw_active为只显示当前光标所在的代码控制域</span></span><br><span class="line">    <span class="string">"indent_guide_options"</span>: [<span class="string">"draw_normal"</span>],</span><br><span class="line">    <span class="comment">// 为true时，保存文件时会删除每行结束后多余的空格</span></span><br><span class="line">    <span class="string">"trim_trailing_white_space_on_save"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 为true时，保存文件时光标会在文件的最后向下换一行</span></span><br><span class="line">    <span class="string">"ensure_newline_at_eof_on_save"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 切换到其它文件标签或点击其它非本软件区域，文件自动保存</span></span><br><span class="line">    <span class="string">"save_on_focus_lost"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"atomic_save"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 编码时不能自动检测编码时，将自动检测ASCII, UTF-8 和 UTF-16</span></span><br><span class="line">    <span class="string">"fallback_encoding"</span>: <span class="string">"Western (Windows 1252)"</span>,</span><br><span class="line">    <span class="comment">// 默认编码格式</span></span><br><span class="line">    <span class="string">"default_encoding"</span>: <span class="string">"UTF-8″,</span></span><br><span class="line"><span class="string">// 包含空字节的文件被打开默认为十六进制</span></span><br><span class="line"><span class="string">"</span>enable_hexadecimal_encoding<span class="string">": true,</span></span><br><span class="line"><span class="string">// 每一行结束的时候用什么字符做终止符</span></span><br><span class="line"><span class="string">"d</span>efault_line_ending<span class="string">": "</span>system<span class="string">",</span></span><br><span class="line"><span class="string">// 通过写入备用文件，然后将其重命名为原始文件</span></span><br><span class="line"><span class="string">"</span>show_definitions<span class="string">": true,</span></span><br><span class="line"><span class="string">// 设置为enabled时，在一个字符串间按Tab将插入一个制表符</span></span><br><span class="line"><span class="string">// 设置为true时，按Tab会根据前后环境进行代码自动匹配填补</span></span><br><span class="line"><span class="string">"</span>tab_completion<span class="string">": true,</span></span><br><span class="line"><span class="string">// 代码提示</span></span><br><span class="line"><span class="string">"</span>auto_complete<span class="string">": true,</span></span><br><span class="line"><span class="string">// 代码提示的大小限制</span></span><br><span class="line"><span class="string">"</span>auto_complete_size_limit<span class="string">": 4194304,</span></span><br><span class="line"><span class="string">// 代码提示延迟显示</span></span><br><span class="line"><span class="string">"</span>auto_complete_delay<span class="string">": 50,</span></span><br><span class="line"><span class="string">"</span>auto_complete_selecto<span class="string">r": "</span>meta.tag - punctuation.definition.tag.begin, source - comment - <span class="built_in">string</span>.quoted.<span class="built_in">double</span>.block - <span class="built_in">string</span>.quoted.single.block - <span class="built_in">string</span>.unquoted.heredoc<span class="string">",</span></span><br><span class="line"><span class="string">// 触发代码提示的其他情况</span></span><br><span class="line"><span class="string">"</span>auto_complete_triggers<span class="string">": [ &#123;"</span>selecto<span class="string">r": "</span>text.html<span class="string">", "c</span>haracters<span class="string">": "</span>&lt;<span class="string">"&#125; ],</span></span><br><span class="line"><span class="string">// 设false时，选择提示的代码按enter或点击可以自动补全，设true时将自动直接换行，功能由tab键替换</span></span><br><span class="line"><span class="string">"</span>auto_complete_commit_on_tab<span class="string">": false,</span></span><br><span class="line"><span class="string">// 控制是否在代码段处于活动状态时自动完成</span></span><br><span class="line"><span class="string">// 仅当auto_complete_commit_on_tab为true有效。</span></span><br><span class="line"><span class="string">"</span>auto_complete_with_fields<span class="string">": false,</span></span><br><span class="line"><span class="string">// 控制当选择自动完成窗口中第一个元素时会发成什么：设false时，窗口将隐藏，否则将选中最后一个元素</span></span><br><span class="line"><span class="string">"</span>auto_complete_cycle<span class="string">": false,</span></span><br><span class="line"><span class="string">// 当输入&lt;/时，自动闭合HTML或XML标签</span></span><br><span class="line"><span class="string">"</span>auto_close_tags<span class="string">": true,</span></span><br><span class="line"><span class="string">// 设置为false，使用Shift + tab总是插入制表符</span></span><br><span class="line"><span class="string">"</span>shift_tab_unindent<span class="string">": false,</span></span><br><span class="line"><span class="string">// 设true时，在当前行，复制和剪切命令会分开</span></span><br><span class="line"><span class="string">"c</span>opy_with_empty_selection<span class="string">": true,</span></span><br><span class="line"><span class="string">// 选中的文本按Ctrl + f时，自动复制到查找面板的文本框里</span></span><br><span class="line"><span class="string">"</span>find_selected_text<span class="string">": true,</span></span><br><span class="line"><span class="string">// 设true时，选中多行文本后，"</span>Find <span class="keyword">in</span> Selection<span class="string">"标志将自动启用</span></span><br><span class="line"><span class="string">"</span>auto_find_in_selection<span class="string">": false,</span></span><br><span class="line"><span class="string">// 设true时，点击所选文本将开始拖放操作，Linux下不可用</span></span><br><span class="line"><span class="string">"d</span>rag_text<span class="string">": true,</span></span><br><span class="line"><span class="string">// 主题</span></span><br><span class="line"><span class="string">"</span>theme<span class="string">": "</span>Default.sublime-theme<span class="string">",</span></span><br><span class="line"><span class="string">// 滚动的速度</span></span><br><span class="line"><span class="string">"</span>scroll_speed<span class="string">": 1.0,</span></span><br><span class="line"><span class="string">// 左边边栏文件夹动画</span></span><br><span class="line"><span class="string">"</span>tree_animation_enabled<span class="string">": true,</span></span><br><span class="line"><span class="string">// 控制应用程序的动画</span></span><br><span class="line"><span class="string">"</span>animation_enabled<span class="string">": true,</span></span><br><span class="line"><span class="string">// 高亮修改过的选项卡</span></span><br><span class="line"><span class="string">"</span>highlight_modified_tabs<span class="string">": false,</span></span><br><span class="line"><span class="string">// 标签页的关闭按钮</span></span><br><span class="line"><span class="string">"</span>show_tab_close_buttons<span class="string">": true,</span></span><br><span class="line"><span class="string">// 加粗侧边栏文件标签</span></span><br><span class="line"><span class="string">"</span>bold_folder_labels<span class="string">": false,</span></span><br><span class="line"><span class="string">// 针对OS X</span></span><br><span class="line"><span class="string">"</span>use_simple_full_screen<span class="string">": false,</span></span><br><span class="line"><span class="string">// 针对OS X</span></span><br><span class="line"><span class="string">"</span>gpu_window_buffe<span class="string">r": "</span><span class="keyword">auto</span><span class="string">",</span></span><br><span class="line"><span class="string">// 水平垂直滚动条：system和disabled为默认显示方式，enabled为自动隐藏显示</span></span><br><span class="line"><span class="string">"</span>overlay_scroll_bars<span class="string">": "</span>system<span class="string">",</span></span><br><span class="line"><span class="string">// 允许选项卡左右滚动</span></span><br><span class="line"><span class="string">"</span>enable_tab_scrolling<span class="string">": true,</span></span><br><span class="line"><span class="string">// 状态栏显示文件编码</span></span><br><span class="line"><span class="string">"</span>show_encoding<span class="string">": false,</span></span><br><span class="line"><span class="string">// 状态栏显示行结束</span></span><br><span class="line"><span class="string">"</span>show_line_endings<span class="string">": false,</span></span><br><span class="line"><span class="string">// 热推出功能！退出时不会提示是否保存文件，而是直接退出</span></span><br><span class="line"><span class="string">// 下次打开软件时，文件保持退出前的状态，没来得及保存的内容都在，但并没有真实的写在原文件里</span></span><br><span class="line"><span class="string">"</span>hot_exit<span class="string">": true,</span></span><br><span class="line"><span class="string">// 全屏模式退出时，下次将以全屏模式启动</span></span><br><span class="line"><span class="string">"</span>remember_full_screen<span class="string">": false,</span></span><br><span class="line"><span class="string">// 重载文件前始终提示，即使文件未被修改。</span></span><br><span class="line"><span class="string">// 默认情况下，文件尚未编辑将自动重载，如果尚未保存修改将始终显示提示。</span></span><br><span class="line"><span class="string">"</span>always_prompt_for_file_reload<span class="string">": false,</span></span><br><span class="line"><span class="string">// 针对OS X</span></span><br><span class="line"><span class="string">"</span>open_files_in_new_window<span class="string">": true,</span></span><br><span class="line"><span class="string">// 针对OS X</span></span><br><span class="line"><span class="string">"c</span>reate_window_at_startup<span class="string">": true,</span></span><br><span class="line"><span class="string">// 设true时，一但最后一个文件关闭将关闭程序窗口，除非窗口中打开了文件夹。</span></span><br><span class="line"><span class="string">"c</span>lose_windows_when_empty<span class="string">": false,</span></span><br><span class="line"><span class="string">// 标题栏显示完整路径</span></span><br><span class="line"><span class="string">"</span>show_full_path<span class="string">": true,</span></span><br><span class="line"><span class="string">// 显示构建结果面板，设false时，则通过"</span>Tools/Build Results<span class="string">"菜单显示</span></span><br><span class="line"><span class="string">"</span>show_panel_on_build<span class="string">": true,</span></span><br><span class="line"><span class="string">// 在发生错误的行下显示构建错误</span></span><br><span class="line"><span class="string">"</span>show_errors_inline<span class="string">": true,</span></span><br><span class="line"><span class="string">// 单机侧边栏文件可预览，双击或编辑预览将打开文件分配选项卡</span></span><br><span class="line"><span class="string">"</span>preview_on_click<span class="string">": true,</span></span><br><span class="line"><span class="string">// 哪些文件会被显示到侧边栏文件夹中</span></span><br><span class="line"><span class="string">"</span>folder_exclude_patterns<span class="string">": ["</span>.svn<span class="string">", "</span>.git<span class="string">", "</span>.hg<span class="string">", "</span>CVS<span class="string">"],</span></span><br><span class="line"><span class="string">"</span>file_exclude_patterns<span class="string">": ["</span>*.pyc<span class="string">", "</span>*.pyo<span class="string">", "</span>*.exe<span class="string">", "</span>*.dll<span class="string">", "</span>*.obj<span class="string">","</span>*.o<span class="string">", "</span>*.a<span class="string">", "</span>*.lib<span class="string">", "</span>*.so<span class="string">", "</span>*.dylib<span class="string">", "</span>*.ncb<span class="string">", "</span>*.sdf<span class="string">", "</span>*.suo<span class="string">", "</span>*.pdb<span class="string">", "</span>*.idb<span class="string">", "</span>.DS_Store<span class="string">", "</span>*.<span class="keyword">class</span><span class="string">", "</span>*.psd<span class="string">", "</span>*.db<span class="string">", "</span>*.sublime-workspace<span class="string">"],</span></span><br><span class="line"><span class="string">// 以下二进制文件仍将显示在侧边栏中，但不会包含在Goto/Goto Anything或Find in Files中</span></span><br><span class="line"><span class="string">"</span>binary_file_patterns<span class="string">": ["</span>*.jpg<span class="string">", "</span>*.jpeg<span class="string">", "</span>*.png<span class="string">", "</span>*.gif<span class="string">", "</span>*.ttf<span class="string">", "</span>*.tga<span class="string">", "</span>*.dds<span class="string">", "</span>*.ico<span class="string">", "</span>*.eot<span class="string">", "</span>*.pdf<span class="string">", "</span>*.swf<span class="string">", "</span>*.ja<span class="string">r", "</span>*.zip<span class="string">"],</span></span><br><span class="line"><span class="string">// 文件索引</span></span><br><span class="line"><span class="string">"</span>index_files<span class="string">": true,</span></span><br><span class="line"><span class="string">// 设置用于索引的编码线程。</span></span><br><span class="line"><span class="string">// 值为0将使Sublime 基于数量猜测，使用index_files将禁用所有工作</span></span><br><span class="line"><span class="string">"</span>index_workers<span class="string">": 0,</span></span><br><span class="line"><span class="string">// 指示哪些文件不用索引</span></span><br><span class="line"><span class="string">"</span>index_exclude_patterns<span class="string">": ["</span>*.log<span class="string">"],</span></span><br><span class="line"><span class="string">// 删除你想要忽略的插件，需要重启, 去掉Vinage开启vim模式</span></span><br><span class="line"><span class="string">"</span>ignored_packages<span class="string">": ["</span>Vintage<span class="string">"]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在编写自己的配置文件时，只需要设置不同的部分即可，避免重复。</p><p><strong>注意</strong>：每行最后用逗号分隔，处最后一行外都不可少，否则会弹出提示，无法保存。</p><h2 id="Sublime-插件"><a href="#Sublime-插件" class="headerlink" title="Sublime 插件"></a>Sublime 插件</h2><p>1.Boxy Theme</p><p>一款为Sublime Text 3 3103以上版本开发的主题，该主题使用<code>A File Icon</code>图标库，所以要想更完整的使用该主题，可以安装该图标插件。插件详情可访问 <a href="https://packagecontrol.io/packages/Boxy%20Theme" target="_blank" rel="noopener">Package Control</a> 官网</p><p>2.SideBarEnhancements</p><p>侧边栏增强插件，能给侧边栏增加很多选项。插件详情可访问 <a href="https://packagecontrol.io/packages/SideBarEnhancements" target="_blank" rel="noopener">Package Control</a> 官网，或者 <a href="https://github.com/titoBouzout/SideBarEnhancements/tree/st3" target="_blank" rel="noopener">SideBarEnhancements</a> 开源库。</p><p>3.SyncedSidebarBg</p><p>这是用来使侧边栏与主面板颜色主题同步的插件，如果安装了其他的颜色主题便可不比在使用该插件。</p><p>4.Emmet</p><p>前身为 <code>Zen Coding</code>，是个能大幅提高开发效率的工具，主要快捷键：<code>Tab</code>用于标签自动补全。完整的快捷方式可访问 <a href="http://emmet.evget.com/" target="_blank" rel="noopener">Emmet 快捷方式查询</a></p><p>5.CSScomb</p><p>CSScomb 是一个超级爽的前端css属性排序工具，用来规则CSS。另外，可以去官网定制自己喜欢的 CSS 样式规则，详情访问<a href="http://csscomb.com/config" target="_blank" rel="noopener">CSScomb在线配置参数</a>。</p><p><strong>提醒</strong>：使用 CSScomb 需要 <code>node.js</code> 的支持，同时要在 CSScomb 中设置 node.js 路径，它默认只有 linux 下的路径，没有 Windows 的，可以参考以下格式：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"node-path" : "D:<span class="symbol">\\</span>Nodejs<span class="symbol">\\</span>node_modules<span class="symbol">\\</span>npm<span class="symbol">\\</span>bin",</span><br></pre></td></tr></table></figure><p>6.DocBlockr</p><p>用来生成注释的插件，定义一个函数f(a,b){}，然后在它前面输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br></pre></td></tr></table></figure><p>然后 <code>Tab</code> 一下，就能生成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [fun description]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  a [description]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  b [description]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>   [description]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">int <span class="function"><span class="title">fun</span><span class="params">(int a, int b)</span></span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不想生成那么多内容，可以只输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br></pre></td></tr></table></figure><p>然后生成如下内容：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">int <span class="function"><span class="title">fun</span><span class="params">(int a, int b)</span></span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.SublimeTmpl</p><p>文件模板插件，帮助我们生成相应的模板，提高效率，目前支持 <code>html/js/css/php/python/ruby</code> ，快捷方式：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Alt+H html</span><br><span class="line">Ctrl+Alt+<span class="keyword">J </span><span class="keyword">javascript</span></span><br><span class="line"><span class="keyword">Ctrl+Alt+C </span>css</span><br><span class="line">Ctrl+Alt+P php</span><br><span class="line">Ctrl+Alt+R ruby</span><br><span class="line">Ctrl+Alt+<span class="keyword">Shift+P </span>python</span><br></pre></td></tr></table></figure><p>详情可访问 <a href="http://www.fantxi.com/blog/archives/sublime-template-engine-sublimetmpl/" target="_blank" rel="noopener">Kairyou’s Blog</a> 或 <a href="https://github.com/kairyou/SublimeTmpl" target="_blank" rel="noopener">SublimeTmpl</a></p><p>8.ConvertToUTF8</p><p>让 Sublime 支持 Unicode 编码，防止出现中文乱码。</p><p>9.HTML/CSS/JS Prettify</p><p>HTML/CSS/JS 代码格式化插件，快捷方式：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+<span class="built_in">Shift</span>+H</span><br></pre></td></tr></table></figure><p>10.Anaconda</p><p>Python 开发的小伙伴都知道，由于该插件使用<code>PEP8</code>编码规范，每行长度不超过80，所以代码中会出现很多白框，这个可以在插件配置中关掉。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">"anaconda_linting":</span> <span class="literal">false</span><span class="string">,</span></span><br></pre></td></tr></table></figure><p>11.NASM x86 Assembly</p><p>Assembly插件，用于编写汇编(x86架构)程序。</p><p>12.OminiMarkupPreviewer</p><p><code>Markdown</code> 文件预览插件，主要快捷方式：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Alt+<span class="keyword">O</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000004577644" target="_blank" rel="noopener">CSScomb的安装和参数配置以及消除空行</a></li><li><a href="http://frontenddev.org/article/sublime-does-text-3-plug-in-docblockr-with-javascript-comments-specification.html" target="_blank" rel="noopener">sublime text 3 插件：DocBlockr与javascript注释规范</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Sublime 已有好几年了，在此分享使用 Sublime 的相关设置及常用插件。&lt;/p&gt;
    
    </summary>
    
      <category term="工具利器" scheme="http://blog.floretten.com/categories/%E5%B7%A5%E5%85%B7%E5%88%A9%E5%99%A8/"/>
    
    
      <category term="Sublime" scheme="http://blog.floretten.com/tags/Sublime/"/>
    
  </entry>
  
  <entry>
    <title>CSS 引入方式与选择器</title>
    <link href="http://blog.floretten.com/2016/CSS_Association_CSS_Selector/"/>
    <id>http://blog.floretten.com/2016/CSS_Association_CSS_Selector/</id>
    <published>2016-09-01T11:42:08.000Z</published>
    <updated>2018-01-16T15:06:25.543Z</updated>
    
    <content type="html"><![CDATA[<p>结合<a href="http://www.w3school.com.cn" target="_blank" rel="noopener">W3School</a>及<a href="http://study.163.com" target="_blank" rel="noopener">网易云课堂</a>相关课程梳理一下<code>CSS</code>样式表引入方式及选择器相关的知识点。</p><a id="more"></a><h2 id="CSS-三种引入方式"><a href="#CSS-三种引入方式" class="headerlink" title="CSS 三种引入方式"></a>CSS 三种引入方式</h2><h3 id="行间样式"><a href="#行间样式" class="headerlink" title="行间样式"></a>行间样式</h3><ul><li>写法：在标签中添加<code>style</code>属性，例如：</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> style=<span class="string">"width:100px;"</span>&gt;&lt;/<span class="keyword">div</span>&gt;<span class="comment">//引号中为相应的CSS样式，注意分号“;”</span></span><br></pre></td></tr></table></figure><ul><li>优点：优先级最高；</li><li>缺点：影响范围小，代码重用率低，不利于维护，不推荐使用；</li></ul><h3 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a>内部样式</h3><ul><li>写法：在<code>head</code>标签中，内嵌<code>style</code>标签，在标签中通过<code>选择器</code>来控制样式</li><li>优点：加载速度快，不需要请求服务器；</li><li>缺点：不利于代码重用</li></ul><h3 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h3><ul><li><p>写法：</p><p>  1.链接式：在<code>head</code>标签中内嵌<code>link</code>标签，用来关联一个<code>CSS</code>文件，在CSS文件中，通过<code>选择器</code>在控制样式；链接式使用的是HTML的规则，在网页文件主体装载前装载CSS文件，因此显示出来的网页从一开始就是带样式的效果的。</p>  <figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link <span class="keyword">rel</span>=<span class="string">"stylesheet"</span> href=<span class="string">"xxx/example.css"</span>&gt;<span class="comment">//href引号中是.CSS文件的路径</span></span><br></pre></td></tr></table></figure><p>  2.导入式：在<code>head</code>标签中内嵌<code>style</code>标签，用来关联一个<code>CSS</code>文件，在CSS文件中，通过<code>选择器</code>在控制样式，这与链接式导入法相同；导入式使用的是CSS的规则，在整个网页装载完后再装载CSS文件，如果网页比较大的话则会出现先显示无样式的页面，闪烁之后，才出现网页的样式。故不推荐使用</p>  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style <span class="class"><span class="keyword">type</span></span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">    <span class="meta">@import</span><span class="string">"mystyle.css"</span>;<span class="comment">//import引号中是.css文件的路径</span></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>优点：利于代码重用；</p></li><li>缺点：需要加载服务器；</li></ul><hr><h2 id="CSS-元素选择器"><a href="#CSS-元素选择器" class="headerlink" title="CSS 元素选择器"></a>CSS 元素选择器</h2><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>最常见的选择器，直接将文档元素作为选择器，实现方法为：<br><strong>标签名&nbsp;&nbsp;{&nbsp;属性:属性值;&nbsp;&nbsp;&nbsp;&nbsp;//CSS样式，同样注意分号“<code>;</code>”&nbsp;}</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123; <span class="attribute">font-size</span>: <span class="number">20px</span>; &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br></pre></td></tr></table></figure><h3 id="id-选择器"><a href="#id-选择器" class="headerlink" title="id 选择器"></a>id 选择器</h3><p>首先在相应的标签中添加一个名为<code>id</code>的属性，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"name"</span>&gt;</span>His name is Ray.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后使用<code>#</code>添加选择器：<br><strong>#id名&nbsp;&nbsp;{&nbsp;属性:属性值;&nbsp;&nbsp;&nbsp;&nbsp;//CSS样式，同样注意分号“<code>;</code>”&nbsp;}</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#name</span> &#123; <span class="attribute">color</span>:red; &#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<br>1、id名要以英文字幕开头；<br>2、id名是唯一的，不可重复；<br>3、id选择器不能结合使用，因为id属性不允许有以空格分隔的词列表。<br>4、id选择器可能区分大小写，这取决于文档的语言。</p><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>首先在相应的标签中添加一个名为<code>class</code>的属性，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">    His name is Ray.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后使用<code>.</code>添加选择器：<br><strong>.类名&nbsp;&nbsp;{&nbsp;属性:属性值;&nbsp;&nbsp;&nbsp;&nbsp;//CSS样式，同样注意分号“<code>;</code>”&nbsp;}</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.name</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<br>1、class名要以英文字母开头；<br>2、class名可以重复，因此它可以同时控制多个标签的样式；<br>3、可以结合标签选择器使用。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.name</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><p>此时选择器会匹配<code>class</code>属性包含<code>name</code>的所有<code>p</code>元素，而其他任何类型的元素都不匹配，不论其是否有此<code>class</code>属性。即选择器<code>p.name</code>解释为：“其<code>class</code>属性值为<code>name</code>的所有段落”。<br>4、可以使用<code>class词列表</code>。在 HTML 中，一个<code>class</code>值中可能包含一个词列表，各个词之间用空格分隔。那么这时可以这样处理，将两个类选择器链接在一起，仅可以选择同时包含这些类名的元素（类名的顺序不限）。如果一个多类选择器包含类名列表中没有的一个类名，匹配就会失败。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.name</span><span class="selector-class">.sex</span> &#123;<span class="attribute">background-color</span>: red;&#125;</span><br></pre></td></tr></table></figure><p>此时该选择器会去匹配<code>class</code>属性值同时包含<code>name</code>和<code>sex</code>的标签，若没有则该样式无法实现。</p><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>如果希望选择有某个属性的元素，而不论属性值是什么，可以使用简单属性选择器，而不仅限于<code>class</code>和<code>id</code>属性。实现方法为：</p><p>首先在相应的标签中添加一个属性，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"www.floretten.com"</span> <span class="attr">title</span>=<span class="string">"nextNote"</span> <span class="attr">target</span>=<span class="string">"_blink"</span>&gt;</span>Ray<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后使用<code>[]</code>添加选择器：<br><strong>[属性]&nbsp;&nbsp;{&nbsp;属性:属性值;&nbsp;&nbsp;&nbsp;&nbsp;//CSS样式，同样注意分号“<code>;</code>”&nbsp;}</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><p>此时，选择器只匹配<code>a</code>元素中的<code>href</code>元素，除此之外，还可以根据多个属性进行选择，只需将属性选择器链接在一起。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span><span class="selector-attr">[title]</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<br>1、属性选择器并不限于这一种形式，如下表：</p><table><thead><tr><th style="text-align:center">选择器</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">[attribute]</td><td style="text-align:center">用于选取带有指定属性的元素</td></tr><tr><td style="text-align:center">[attribute=value]</td><td style="text-align:center">用于选取带有指定属性和值的元素</td></tr><tr><td style="text-align:center">[attribute`=value ]</td><td style="text-align:center">用于选取属性值中包含指定词汇的元素</td></tr><tr><td style="text-align:center">[attribute&#124;=value ]</td><td style="text-align:center">用于选取带有以指定值开头的属性值的元素，该值必须是整个单词</td></tr><tr><td style="text-align:center">[attribute^=value ]</td><td style="text-align:center">匹配属性值以指定值开头的每个元素</td></tr><tr><td style="text-align:center">[attribute$=value ]</td><td style="text-align:center">匹配属性值以指定值结尾的每个元素</td></tr><tr><td style="text-align:center">[attribute*=value ]</td><td style="text-align:center">匹配属性值中包含指定值的每个元素</td></tr></tbody></table><p>2、在使用<code>属性=属性值</code>选择器时，要求属性值必须<strong>完全</strong>适配，如果属性值包含用空格分隔的值列表，匹配就会出问题。</p><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>后代选择器可以让样式只在文档某些结构中起作用，而在其他部分不起作用。例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><p>此时样式只会对<code>div</code>元素中的<code>p</code>元素及其所有后代及起作用，而对<code>div</code>中其他部分不起作用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>His <span class="tag">&lt;<span class="name">strong</span>&gt;</span>name<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> is <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Ray<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>His <span class="tag">&lt;<span class="name">strong</span>&gt;</span>name<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> is <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Ray<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在后代选择器中，规则左边的选择器一端包括两个或多个用空格分隔的选择器。选择器之间的空格是一种结合符（combinator）。每个空格结合符可以解释为“… 在 … 找到”、“… 作为 … 的一部分”、“… 作为 … 的后代”，但是要求必须从右向左读选择器。</p></blockquote><p>因此，<code>div p</code>选择器可以解释为“作为<code>div</code>元素后代的任何<code>p</code>元素”。如果要从左向右读选择器，可以换成以下说法：“包含<code>p</code>的所有<code>div</code>会把以下样式应用到该<code>p</code>”。</p><h3 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h3><p>相比于后代选择器，子元素选择器影响范围更小，它只能选择作为某元素子元素的元素,即两者必须是直接的父子关系。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure><p>这句代码中只会对含有<code>div</code>的子元素<code>p</code>标签及其后代起作用，如果改成div &gt; strong，该样式则无效。</p><p><strong>后代选择器和子选择器结合使用</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.name</span> <span class="selector-tag">p</span> &gt; <span class="selector-tag">strong</span></span><br></pre></td></tr></table></figure><p>上面的选择器会选择作为<code>p</code>元素子元素的所有<code>strong</code>元素，这个<code>p</code>元素本身从<code>div</code>元素继承，该<code>div</code>元素有一个包含<code>name</code>的<code>class</code>属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">His <span class="tag">&lt;<span class="name">strong</span>&gt;</span>name<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> is <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Ray.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">selector</span> : <span class="selector-tag">pseudo-class</span> &#123;<span class="attribute">property</span>: value&#125;</span><br></pre></td></tr></table></figure><p>伪类可与 CSS 类搭配使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">selector</span><span class="selector-class">.class</span> : <span class="selector-tag">pseudo-class</span> &#123;<span class="attribute">property</span>: value&#125;</span><br></pre></td></tr></table></figure><p>比较常见的是<code>锚伪类</code></p><p>在支持 CSS 的浏览器中，链接的不同状态都可以不同的方式显示，这些状态包括：活动状态，已被访问状态，未被访问状态，和鼠标悬停状态。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>: <span class="number">#FF0000</span>&#125;<span class="comment">/* 未访问的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: <span class="number">#00FF00</span>&#125;<span class="comment">/* 已访问的链接 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>: <span class="number">#FF00FF</span>&#125;<span class="comment">/* 鼠标移动到链接上 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>: <span class="number">#0000FF</span>&#125;<span class="comment">/* 选定的链接 */</span></span><br></pre></td></tr></table></figure><h3 id="选择器分组"><a href="#选择器分组" class="headerlink" title="选择器分组"></a>选择器分组</h3><p>如果希望多个元素具有相同的样式，可以将多个选择器用逗号<code>,</code>分组在一起，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span>,<span class="selector-tag">body</span>,<span class="selector-tag">p</span>,<span class="selector-tag">td</span>,<span class="selector-tag">th</span>,<span class="selector-tag">pre</span>,<span class="selector-class">.name</span>,<span class="selector-class">.sex</span> &#123;<span class="attribute">color</span>:green;&#125;</span><br></pre></td></tr></table></figure><p>在选择其中，逗号告诉浏览器规则中包含多个选择器，样式对它们都起作用。</p><p><strong>有关 CSS 更多内容可以访问</strong>：<a href="http://www.w3school.com.cn" target="_blank" rel="noopener">W3School</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;结合&lt;a href=&quot;http://www.w3school.com.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;W3School&lt;/a&gt;及&lt;a href=&quot;http://study.163.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网易云课堂&lt;/a&gt;相关课程梳理一下&lt;code&gt;CSS&lt;/code&gt;样式表引入方式及选择器相关的知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发" scheme="http://blog.floretten.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="CSS" scheme="http://blog.floretten.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>使用 Travis CI 自动部署 Hexo</title>
    <link href="http://blog.floretten.com/2016/Travis_CI_Hexo/"/>
    <id>http://blog.floretten.com/2016/Travis_CI_Hexo/</id>
    <published>2016-08-27T02:30:14.000Z</published>
    <updated>2018-02-28T04:29:03.300Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于使用<code>Hexo</code>部署网站的繁琐性，便利用软件开发中的持续集成工具<code>Travis CI</code>来帮助完成这一繁杂过程。</p><a id="more"></a><h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><hr><p>CI是<code>Continuous Integration</code>的缩写，持续集成之意。</p><blockquote><p>持续集成是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p></blockquote><p><img src="http://floretten-1252347631.costj.myqcloud.com/Travis/Continuous.png" alt="Continuous Integration"></p><p>Travis CI 是目前新兴的开源持续集成构建项目，用来构建托管在<code>GitHub</code>上的代码。它提供了多种编程语言的支持，包括Ruby，JavaScript，Java，Scala，PHP，Haskell和Erlang在内的多种语言。许多知名的开源项目使用它来在每次提交的时候进行构建测试，比如Ruby on Rails，Ruby和Node.js。</p><blockquote><p>Travis CI是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码。这个软件的代码同时也是开源的，可以在GitHub上下载到，尽管开发者当前并不推荐在闭源项目中单独使用它。</p></blockquote><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><hr><p>当我们每次进行<code>push</code>等动作时，Travis CI 会自动检测我们的提交，然后根据配置文件，搭建虚拟主机来运行测试，构建等指令。在这里，就是运行<code>hexo g d</code>等命令来自动生成、部署静态网页。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Travis/Travis.png" alt="Travis CI"></p><p>Travis CI 官方文档：<a href="https://docs.travis-ci.com/" target="_blank" rel="noopener">https://docs.travis-ci.com/</a></p><h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><hr><h3 id="Hexo-搭建"><a href="#Hexo-搭建" class="headerlink" title="Hexo 搭建"></a>Hexo 搭建</h3><p>这里使用<code>Hexo</code>+<code>Next</code>+<code>GitHub Pages</code>组合示范过程，具体过程不再赘述。网站源码放到<code>Hexo</code>分支，博客的静态文件部署到<code>master</code>分支。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Travis/Travis001.png" alt="hexo源代码"></p><h3 id="设置-Travis-CI"><a href="#设置-Travis-CI" class="headerlink" title="设置 Travis CI"></a>设置 Travis CI</h3><p>登陆 Travis CI，使用 GitHub 账户登录，它会自动关联 GitHub 上的仓库。点击右上角用户查看 GitHub 仓库，并选择要启动的项目，这里选择<code>yourname/yourname.github.io</code>。</p><p>点击设置按钮，进入设置选项，开启相关服务，<code>Build only if .travis.yml is present</code>：指只在有<code>.travis.yml</code>时改变了才构建；<code>Build pushes</code>：push 完分支后开始构建。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Travis/Travis005.png" alt="设置"></p><p>访问仓库是需要权限的，下面配置权限信息。</p><h3 id="配置-Acess-Token"><a href="#配置-Acess-Token" class="headerlink" title="配置 Acess Token"></a>配置 Acess Token</h3><p>登陆<a href="https://github.com" target="_blank" rel="noopener">GitHub</a>，进入设置界面，在<code>Personal access tokens</code>页面下点击右上角的<code>Generate new token</code>按钮会生成新的<code>token</code>，随后输入密码，取个名字，勾选一些权限</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Travis/Travis006.png" alt="Personal access tokens"></p><p>拷贝 token 并在 Travis CI 页面中配置<code>Environment Variables</code>。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Travis/Travis008.png" alt="Environment Variables"></p><p>Travis CI 已获得仓库权限，现在可以给它相关操作指令了。</p><h3 id="配置-travis-yml"><a href="#配置-travis-yml" class="headerlink" title="配置 .travis.yml"></a>配置 .travis.yml</h3><p><em>.travis.yml</em> 内容如下：</p><pre><code>language: node_js  #设置语言node_js: stable  #设置相应的版本install:  - npm install  #安装hexo及插件script:  - hexo cl  #清除  - hexo g  #生成after_script:  - cd ./public  - git init  - git config user.name &quot;yourname&quot;  #修改name  - git config user.email &quot;your email&quot;  #修改email  - git add .  - git commit -m &quot;update&quot;  - git push --force --quiet &quot;https://${GH_TOKEN}@${GH_REF}&quot; master:master  #GH_TOKEN是在Travis中配置token的名称branches:  only:    - hexo  #只监测hexo分支，hexo是我的分支的名称，可根据自己情况设置env: global:   - GH_REF: github.com/yourname/yourname.github.io.git  #设置GH_REF，注意更改yourname</code></pre><p><em>.travis.yml</em> 配置完成后，还需要注意一个问题，即 Travis 在创建虚拟机后，如何利用<code>npm install</code>安装 Hexo 及其依赖文件。进行过本地部署的话就不难发现，我们所需要的依赖文件会自动添加到 <em>package.json</em> 列表中，因此 package.json 文件不可少。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Travis/Travis009.png" alt="package.json"></p><p>配置Hexo时还会生成<code>node_modules</code>文件夹，这是 Hexo 及其依赖包的位置，它和 <em>package.json</em> 文件列表是对应的。因此 node_modules 文件夹不需要 push 远程仓库，CI平台的虚拟机会自己创建的。</p><p>另外注意这些文件的<strong>格式</strong>，尤其是<code>.yml</code>的格式，稍有偏差就有可能出问题。</p><h3 id="Push-到-GitHub"><a href="#Push-到-GitHub" class="headerlink" title="Push 到 GitHub"></a>Push 到 GitHub</h3><p>在_posts目录下新建文章并 push 分支，登陆 Travis CI 即可发现已经检测到分支变化并开始构建，其中<code>job log</code>记录了构建的过程。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Travis/Travis013.png" alt="hexo deployer"></p><p>自动部署完成，打开网页查看效果</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Travis/Travis015.png" alt="post"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://lotabout.me/2016/Hexo-Auto-Deploy-to-Github/" target="_blank" rel="noopener">Hexo 自动部署到 Github</a></li><li><a href="http://blog.csdn.net/woblog/article/details/51319364" target="_blank" rel="noopener">手把手教你使用Travis CI自动部署你的Hexo博客到Github上</a></li><li><a href="http://gold.xitu.io/entry/570de1f32e958a0069d567f6" target="_blank" rel="noopener">使用 travis-ci 自动部署 hexo 博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鉴于使用&lt;code&gt;Hexo&lt;/code&gt;部署网站的繁琐性，便利用软件开发中的持续集成工具&lt;code&gt;Travis CI&lt;/code&gt;来帮助完成这一繁杂过程。&lt;/p&gt;
    
    </summary>
    
      <category term="HEXO博客" scheme="http://blog.floretten.com/categories/HEXO%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://blog.floretten.com/tags/Hexo/"/>
    
      <category term="Travis CI" scheme="http://blog.floretten.com/tags/Travis-CI/"/>
    
  </entry>
  
  <entry>
    <title>图的邻接表存储</title>
    <link href="http://blog.floretten.com/2016/Adjacency_List_Graph/"/>
    <id>http://blog.floretten.com/2016/Adjacency_List_Graph/</id>
    <published>2016-08-26T13:45:54.000Z</published>
    <updated>2018-02-28T04:26:46.777Z</updated>
    
    <content type="html"><![CDATA[<p>整理数据结构代码，回顾图的存储方式及相关算法。</p><a id="more"></a><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><hr><p><strong>图</strong>(Graph)是一种较线性表和树更为复杂的结构。图有两个重要元素构成，顶点和弧边，弧边是相关顶点之间的连线，具有方向性，根据方向性的有无，图可以分为有向图和无向图。</p><p>(1) 无向图。在一个图中，如果任意两个顶点构成的偶对（vi, vj）∈E 是无序的，即顶点之间的连线是没有方向的，则称该图为无向图。如下图就是一个无向图。<br>(2) 有向图。在一个图中，如果任意两个顶点构成的偶对（vi, vj）∈E 是有序的，即顶点之间的连线是有方向的，则称该图为有向图。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Graph/Graph.jpg" alt="无向图"></p><h2 id="图的抽象数据类型定义"><a href="#图的抽象数据类型定义" class="headerlink" title="图的抽象数据类型定义"></a>图的抽象数据类型定义</h2><hr><blockquote><p>ADT  Graph{<br>数据对象：n=n是具有相同特征的数据元素集合，称为顶点集。<br>数据关系：DR={<v,w>|v,w∈n且<v,w>表示从v指向w的弧<br>}</v,w></v,w></p></blockquote><h2 id="图的邻接表存储代码实现"><a href="#图的邻接表存储代码实现" class="headerlink" title="图的邻接表存储代码实现"></a>图的邻接表存储代码实现</h2><hr><p>邻接表是图的一种最主要存储结构，它由表头结点和表结点两部分组成，其中每个顶点均对应一个存储在数组中的表头结点。简言之，对图的每个顶点建立一个容器（n个顶点建立n个容器），第i个容器中的结点包含顶点Vi的所有邻接顶点。<br>在有向图中，描述每个点向别的节点连的边（点a-&gt;点b这种情况）；在无向图中，描述每个点所有的边(点a-点b这种情况)。</p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Graph/AdjacencyList.png" alt="邻接表"></p><h3 id="图的顶点及弧的定义"><a href="#图的顶点及弧的定义" class="headerlink" title="图的顶点及弧的定义"></a>图的顶点及弧的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//边表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex; <span class="comment">//该边所指顶点位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span> <span class="comment">//指向下一条弧的指针</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VerNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexType data; <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstarc; <span class="comment">//指向第一条依附该顶点的弧</span></span><br><span class="line">&#125; VerNode, AdjList[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="comment">//图定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum; <span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">    <span class="comment">//int kind; //图的种类标志</span></span><br><span class="line">&#125; ALGraph;</span><br></pre></td></tr></table></figure><h3 id="图的创建"><a href="#图的创建" class="headerlink" title="图的创建"></a>图的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> visit[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点元素定位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(ALGraph *G, VertexType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">-1</span>; <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;vertices[i].data == e)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表头插</span></span><br><span class="line"><span class="function">Status <span class="title">HeadInsertArc</span><span class="params">(ALGraph *G, <span class="keyword">int</span> pos, <span class="keyword">int</span> adjvex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArcNode *e;</span><br><span class="line">    e = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">    e-&gt;adjvex = adjvex;</span><br><span class="line">    e-&gt;nextarc = G-&gt;vertices[pos].firstarc;</span><br><span class="line">    G-&gt;vertices[pos].firstarc = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表尾插</span></span><br><span class="line"><span class="function">Status <span class="title">TailInsertArc</span><span class="params">(ALGraph *G, <span class="keyword">int</span> pos, <span class="keyword">int</span> adjvex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArcNode *e, *p;</span><br><span class="line">    e = (ArcNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">    e-&gt;adjvex = adjvex;</span><br><span class="line">    e-&gt;nextarc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (G-&gt;vertices[pos].firstarc == <span class="literal">NULL</span>)</span><br><span class="line">        G-&gt;vertices[pos].firstarc = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = G-&gt;vertices[pos].firstarc;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;nextarc)</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        p-&gt;nextarc = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建图</span></span><br><span class="line"><span class="function">Status <span class="title">CreateGraph</span><span class="params">(ALGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input the vexnum and arcnum:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;(G-&gt;vexnum), &amp;(G-&gt;arcnum));</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        G-&gt;vertices[i].data = getchar();</span><br><span class="line">        G-&gt;vertices[i].firstarc = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;arcnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> arc_s, arc_e;</span><br><span class="line">        arc_s = getchar(); arc_e = getchar();</span><br><span class="line">        <span class="keyword">int</span> v_s = LocateVex(G, arc_s);</span><br><span class="line">        <span class="keyword">int</span> v_e = LocateVex(G, arc_e);</span><br><span class="line">        <span class="comment">//HeadInsertArc(G, v_s, v_e);</span></span><br><span class="line">        <span class="comment">//HeadInsertArc(G, v_e, v_s);</span></span><br><span class="line">        TailInsertArc(G, v_s, v_e);</span><br><span class="line">        TailInsertArc(G, v_e, v_s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>在G中任选一顶点v为初始出发点(源点)，则深度优先遍历可定义如下：首先访问出发点v，并将其标记为已访问过；然后依次从v出发搜索v的每个邻接点w。若w未曾访问过，则以w为新的出发点继续进行深度优先遍历，直至图中所有和源点v有路径相通的顶点(亦称为从源点可达的顶点)均已被访问为止。若此时图中仍有未访问的顶点，则另选一个尚未访问的顶点作为新的源点重复上述过程，直至图中所有顶点均已被访问为止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function">Status <span class="title">DFS_Non_Recursion</span><span class="params">(ALGraph *G, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, G-&gt;vertices[i].data);</span><br><span class="line">    visit[i] = <span class="number">1</span>;</span><br><span class="line">    p = G-&gt;vertices[i].firstarc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit[p-&gt;adjvex])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, G-&gt;vertices[p-&gt;adjvex].data);</span><br><span class="line">            visit[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;nextarc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function">Status <span class="title">DFS_Recursion</span><span class="params">(ALGraph *G, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, G-&gt;vertices[i].data);</span><br><span class="line">    p = G-&gt;vertices[i].firstarc;</span><br><span class="line">    visit[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit[p-&gt;adjvex])</span><br><span class="line">        &#123;</span><br><span class="line">            DFS_Recursion(G, p-&gt;adjvex);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;nextarc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function">Status <span class="title">DFSTraverse</span><span class="params">(ALGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">        visit[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++)</span><br><span class="line">        <span class="keyword">if</span> (!visit[i]) DFS_Non_Recursion(G, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>从图中某个顶点V0出发，并访问此顶点；然后访问V0的各个未曾访问的邻接点W1，W2，…,Wk;然后,依次从W1,W2,…,Wk出发访问各自未被访问的邻接点；重复步骤第二个步骤，直到全部顶点都被访问为止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function">Status <span class="title">BFSTraverse</span><span class="params">(ALGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i; LinkQueue Q;</span><br><span class="line">    InitQueue(&amp;Q); <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i++) <span class="comment">//设置所为顶点为未访问</span></span><br><span class="line">        visit[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == visit[i]) <span class="comment">//选取未访问的顶点</span></span><br><span class="line">        &#123;</span><br><span class="line">            visit[i] = <span class="number">1</span>; <span class="comment">//未访问,则(只)访问一次</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, G-&gt;vertices[i].data);</span><br><span class="line">            EnQueue(&amp;Q, i); <span class="comment">//已访问则进队</span></span><br><span class="line">            <span class="keyword">while</span> (!QueueEmpty(&amp;Q)) <span class="comment">//队列不为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                DeQueue(&amp;Q, &amp;i); <span class="comment">//出队</span></span><br><span class="line">                ArcNode *p = G-&gt;vertices[i].firstarc; <span class="comment">//指向下一个边表结点</span></span><br><span class="line">                <span class="keyword">while</span> (p)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visit[p-&gt;adjvex]) <span class="comment">//未访问结点</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        visit[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%c "</span>, G-&gt;vertices[p-&gt;adjvex].data);</span><br><span class="line">                        EnQueue(&amp;Q, p-&gt;adjvex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = p-&gt;nextarc; <span class="comment">//下一个边表结点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码可参见：<a href="https://github.com/Laueray/Data-Structure/tree/master/5.Graph" target="_blank" rel="noopener">GitHub</a></p><p> <strong>DONE！</strong><br>所示代码如有错误请多加指正，谢谢</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理数据结构代码，回顾图的存储方式及相关算法。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.floretten.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="无向图" scheme="http://blog.floretten.com/tags/%E6%97%A0%E5%90%91%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>顺序队列与链队列的实现</title>
    <link href="http://blog.floretten.com/2016/SqQueue_LinkQueue/"/>
    <id>http://blog.floretten.com/2016/SqQueue_LinkQueue/</id>
    <published>2016-08-15T02:08:14.000Z</published>
    <updated>2018-02-28T04:34:21.762Z</updated>
    
    <content type="html"><![CDATA[<p>整理数据结构代码，回顾两种队列的实现方法。</p><a id="more"></a><h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2><p>与栈相反，队列(queue)是一种<strong>先进先出</strong>(first in first out,缩写为FIFO)的线性表。这和我们日常生活中的排队是一致的，最早进入队列的元素最早离开。在队列中，允许插入的一端叫做<strong>队尾</strong>(rear)，允许删除的一端叫做<strong>队头</strong>(front)。</p><h2 id="抽象数据类型定义"><a href="#抽象数据类型定义" class="headerlink" title="抽象数据类型定义"></a>抽象数据类型定义</h2><p>ADT Queue{<br>    数据对象：D={ai|ai∈ElemSet, i=1,2, …,n, n≥0}<br>    数据关系：R1={&lt;ai-1,ai&gt;|ai-1,ai∈D, i=1,2, …,n }<br>    约定a1为队列头，an为队列尾。<br>}</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="顺序队列-SqQueue"><a href="#顺序队列-SqQueue" class="headerlink" title="顺序队列(SqQueue)"></a>顺序队列(SqQueue)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQSIZE 100 <span class="comment">//队列最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序队列定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType *base;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;base = (QElemType *)<span class="built_in">malloc</span>(MAXQSIZE * <span class="keyword">sizeof</span>(QElemType));</span><br><span class="line">    <span class="keyword">if</span> (!Q-&gt;base) <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q-&gt;rear - Q-&gt;front + MAXQSIZE) % MAXQSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队满</span></span><br><span class="line"><span class="function">Status <span class="title">QueueFull</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXQSIZE == Q-&gt;front)</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队空</span></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue *Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueFull(Q))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q-&gt;base[Q-&gt;rear] = e;</span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue *Q, QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    (*e) = Q-&gt;base[Q-&gt;front];</span><br><span class="line">    Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function">Status <span class="title">Traverse</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; Length(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, Q-&gt;base[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码可参见：<a href="https://github.com/Laueray/Data-Structure/blob/master/3.Queue/SqQueue.c" target="_blank" rel="noopener">GitHub</a></p><p><img src="http://floretten-1252347631.costj.myqcloud.com/Queue/SqQueue.jpg" alt="queue"></p><h3 id="链队列-LinkQueue"><a href="#链队列-LinkQueue" class="headerlink" title="链队列(LinkQueue)"></a>链队列(LinkQueue)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链队列定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span> (!Q-&gt;front) <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue *Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">    p = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;rear-&gt;next = p;</span><br><span class="line">    Q-&gt;rear = p;</span><br><span class="line">    Q-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队空</span></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue *Q, QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">    <span class="keyword">if</span> (QueueEmpty(Q)) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p = Q-&gt;front-&gt;next;</span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line">    Q-&gt;front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p == Q-&gt;rear) Q-&gt;front = Q-&gt;rear;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    Q-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function">Status <span class="title">Destroy</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (Q-&gt;front)</span><br><span class="line">    &#123;</span><br><span class="line">        Q-&gt;rear = Q-&gt;front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(Q-&gt;front);</span><br><span class="line">        Q-&gt;front = Q-&gt;rear;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function">Status <span class="title">Traverse</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueuePtr p;</span><br><span class="line">    p = Q-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://floretten-1252347631.costj.myqcloud.com/Queue/LinkQueue.png" alt="LinkQueue"></p><p>完整代码可参见：<a href="https://github.com/Laueray/Data-Structure/blob/master/3.Queue/LinkQueue.c" target="_blank" rel="noopener">GitHub</a></p><p> <strong>DONE！</strong></p><p>所示代码如有错误请多加指正，谢谢</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理数据结构代码，回顾两种队列的实现方法。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.floretten.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="队列" scheme="http://blog.floretten.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的实现与操作</title>
    <link href="http://blog.floretten.com/2016/BiTree/"/>
    <id>http://blog.floretten.com/2016/BiTree/</id>
    <published>2016-08-11T11:08:14.000Z</published>
    <updated>2017-10-05T08:37:29.781Z</updated>
    
    <content type="html"><![CDATA[<p>整理数据结构代码，回顾二叉树的存储及相关算法。</p><a id="more"></a><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树(Binary Tree)是一种特殊的树形结构，它的特殊在于每个节点至多只有两棵子树，并且二叉树的子树有左右之分，其次序不能任意颠倒。</p><h2 id="抽象数据类型定义"><a href="#抽象数据类型定义" class="headerlink" title="抽象数据类型定义"></a>抽象数据类型定义</h2><p>ADT BinaryTree{<br>    数据对象D：D是具有相同特性的数据元素的集合。<br>    数据关系R：<br>    若D为空集，则称为空二叉树；<br>    若D仅含一个数据元素，则R为空集，否则R = {H}, H是如下二元关系：<br>        （1） 在D中存在唯一的称为根的数据元素root，它在关系H下无前驱；<br>        （2） 若D – {root} ≠ Φ，则存在D – {root} 的一个划分Dl Dr ，Dl∩Dr =Φ;<br>        （3） 若Dl ≠ Φ,则Dl 中存在惟一的数据元素xl ， <root, xl=""> ∈ H，且存在Dl 上的关系Hl &lt; H；若Dr ≠ Φ,则Dr 中存在惟一的数据元素xr ，<root, xr=""> ∈  H，且存在Dr 上的关系Hr &lt; H；<br>        （4）（Dl，{ Hl、}）是一棵符合本定义的二叉树，称为根root的左子树； （Dr，{ Hr、}）是一棵符合本定义的二叉树，称为根root的右子树。<br>}</root,></root,></p><h2 id="二叉树操作代码实现"><a href="#二叉树操作代码实现" class="headerlink" title="二叉树操作代码实现"></a>二叉树操作代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为栈/队列定义栈内元素类型</span></span><br><span class="line"><span class="keyword">typedef</span> BiTree SElemType; <span class="comment">//栈元素为BiTree类型</span></span><br><span class="line"><span class="keyword">typedef</span> BiTree QElemType; <span class="comment">//队列元素为BiTree类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉树</span></span><br><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TElemType e;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;e);</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="string">'#'</span>) *T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        <span class="keyword">if</span> (!(*T)) <span class="keyword">return</span> ERROR;</span><br><span class="line">        (*T)-&gt;data = e;</span><br><span class="line">        CreateBiTree(&amp;((*T)-&gt;lchild));</span><br><span class="line">        CreateBiTree(&amp;((*T)-&gt;rchild));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序非递归</span></span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse_Non_Recursion</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqStack S; InitStack(&amp;S);</span><br><span class="line">    BiTNode *p; p = T;</span><br><span class="line">    <span class="keyword">while</span> (p || !StackEmpty(&amp;S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visit(p))</span><br><span class="line">        &#123;</span><br><span class="line">            PushStack(&amp;S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            PopStack(&amp;S, &amp;p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序非递归</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse_Non_Recursion</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqStack S; InitStack(&amp;S);</span><br><span class="line">    BiTNode *p; p = T;</span><br><span class="line">    <span class="keyword">while</span> (p || !StackEmpty(&amp;S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            PushStack(&amp;S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            PopStack(&amp;S, &amp;p);</span><br><span class="line">            visit(p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序非递归思路二</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse_Non_Recursion_2</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqStack S; InitStack(&amp;S);</span><br><span class="line">    BiTNode *p; PushStack(&amp;S, T);</span><br><span class="line">    <span class="keyword">while</span> (!StackEmpty(&amp;S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (GetTop(&amp;S, &amp;p) &amp;&amp; p)</span><br><span class="line">            PushStack(&amp;S, p-&gt;lchild); <span class="comment">//向左走到尽头</span></span><br><span class="line">        PopStack(&amp;S, &amp;p); <span class="comment">//回退空指针</span></span><br><span class="line">        <span class="keyword">if</span> (!StackEmpty(&amp;S))</span><br><span class="line">        &#123;</span><br><span class="line">            PopStack(&amp;S, &amp;p);</span><br><span class="line">            visit(p);</span><br><span class="line">            PushStack(&amp;S, p-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序非递归</span></span><br><span class="line"><span class="function">Status <span class="title">LevelOrderTraverse_Non_Recursion</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqQueue Q; InitQueue(&amp;Q);</span><br><span class="line">    BiTNode *p; p = T;</span><br><span class="line">    <span class="keyword">if</span> (visit(p)) <span class="comment">//访问根节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        EnQueue(&amp;Q, p); <span class="comment">//根节点入队</span></span><br><span class="line">        <span class="keyword">while</span> (!QueueEmpty(&amp;Q))</span><br><span class="line">        &#123;</span><br><span class="line">            DeQueue(&amp;Q, &amp;p); <span class="comment">//出队</span></span><br><span class="line">            <span class="keyword">if</span> (visit(p-&gt;lchild))</span><br><span class="line">                EnQueue(&amp;Q, p-&gt;lchild);</span><br><span class="line">            <span class="keyword">if</span> (visit(p-&gt;rchild))</span><br><span class="line">                EnQueue(&amp;Q, p-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归计算叶子结点数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountLeaf_Non_Recursion</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leaf = <span class="number">0</span>;</span><br><span class="line">    SqStack S; InitStack(&amp;S);</span><br><span class="line">    BiTNode *p; p = T;</span><br><span class="line">    <span class="keyword">while</span> (p || !StackEmpty(&amp;S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            PushStack(&amp;S, p);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">                leaf++;</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            PopStack(&amp;S, &amp;p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leaf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序输出叶子结点</span></span><br><span class="line"><span class="function">Status <span class="title">LevelOrderTraverse_Leaf</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqQueue Q; InitQueue(&amp;Q);</span><br><span class="line">    BiTNode *p; p = T;</span><br><span class="line">    <span class="keyword">if</span> (p) <span class="comment">//访问根节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        EnQueue(&amp;Q, p); <span class="comment">//根节点入队</span></span><br><span class="line">        <span class="keyword">while</span> (!QueueEmpty(&amp;Q))</span><br><span class="line">        &#123;</span><br><span class="line">            DeQueue(&amp;Q, &amp;p); <span class="comment">//出队</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">                visit(p);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;lchild)</span><br><span class="line">                    EnQueue(&amp;Q, p-&gt;lchild);</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;rchild)</span><br><span class="line">                    EnQueue(&amp;Q, p-&gt;rchild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归交换左右孩子</span></span><br><span class="line"><span class="function">Status <span class="title">ExchangeChild_Non_Recursion</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqStack S; InitStack(&amp;S);</span><br><span class="line">    BiTNode *p; p = T;</span><br><span class="line">    BiTNode *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p || !StackEmpty(&amp;S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            PushStack(&amp;S, p);</span><br><span class="line">            tmp = p-&gt;lchild;</span><br><span class="line">            p-&gt;lchild = p-&gt;rchild;</span><br><span class="line">            p-&gt;rchild = tmp;</span><br><span class="line">            <span class="comment">//swap(p-&gt;lchild,p-&gt;rchild);</span></span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            PopStack(&amp;S, &amp;p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根节点左插入</span></span><br><span class="line"><span class="function">Status <span class="title">Insert_Root_LeftNode</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTNode *p, *q;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    p = T-&gt;lchild;</span><br><span class="line">    q = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    q-&gt;data = e;</span><br><span class="line">    q-&gt;lchild = p;</span><br><span class="line">    q-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;lchild = q;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找父亲节点</span></span><br><span class="line"><span class="function">BiTNode* <span class="title">FindFather</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span> || T-&gt;data == e)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((T-&gt;lchild &amp;&amp; T-&gt;lchild-&gt;data == e) ||</span><br><span class="line">        (T-&gt;rchild &amp;&amp; T-&gt;rchild-&gt;data == e))</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    BiTNode *p = FindFather(T-&gt;lchild, e);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        p = FindFather(T-&gt;rchild, e);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大值与最小值</span></span><br><span class="line"><span class="function">BiTNode* <span class="title">MaxNode</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    BiTNode *pMax = T, *tmp;</span><br><span class="line">    tmp = MaxNode(T-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;data &gt; pMax-&gt;data)</span><br><span class="line">            pMax = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = MaxNode(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">if</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;data &gt; pMax-&gt;data)</span><br><span class="line">            pMax = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码可参见：<a href="https://github.com/Laueray/Data-Structure/blob/master/4.BiTree/BiTree.c" target="_blank" rel="noopener">GitHub</a></p><p> <strong>DONE！</strong><br>所示代码如有错误请多加指正，谢谢</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理数据结构代码，回顾二叉树的存储及相关算法。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.floretten.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉树" scheme="http://blog.floretten.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>顺序栈与链栈的实现</title>
    <link href="http://blog.floretten.com/2016/SqStack_LinkStack/"/>
    <id>http://blog.floretten.com/2016/SqStack_LinkStack/</id>
    <published>2016-07-06T15:55:18.000Z</published>
    <updated>2017-10-06T04:34:59.539Z</updated>
    
    <content type="html"><![CDATA[<p>整理数据结构代码，回顾两种栈的实现方法。</p><a id="more"></a><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><p>栈(Stack)是限定仅在表尾进行插入与删除操作的线性表。于是栈也有两种实现方式，顺序栈和链栈。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><hr><h3 id="顺序栈-SqStack"><a href="#顺序栈-SqStack" class="headerlink" title="顺序栈(SqStack)"></a>顺序栈(SqStack)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType *top; <span class="comment">//栈顶指针</span></span><br><span class="line">    SElemType *base; <span class="comment">//在栈构造之前和销毁之后为NULL</span></span><br><span class="line">    <span class="keyword">int</span> stacksize; <span class="comment">//当前已分配大小</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S-&gt;base = (SElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="keyword">sizeof</span>(SElemType));</span><br><span class="line">    <span class="keyword">if</span> (!S-&gt;base) <span class="keyword">return</span> ERROR;</span><br><span class="line">    S-&gt;top = S-&gt;base;</span><br><span class="line">    S-&gt;stacksize = STACK_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == S-&gt;base)</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈满</span></span><br><span class="line"><span class="function">Status <span class="title">StackFull</span><span class="params">(SqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top - S-&gt;base &gt;= S-&gt;stacksize)</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶</span></span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack *S, SElemType* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(S))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    (*e) = *(S-&gt;top - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈</span></span><br><span class="line"><span class="function">Status <span class="title">PushStack</span><span class="params">(SqStack *S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StackFull(S))</span><br><span class="line">    &#123;</span><br><span class="line">        S-&gt;base = (SElemType *)<span class="built_in">realloc</span>(S-&gt;base,</span><br><span class="line">            (S-&gt;stacksize + STACKINCREMENT)*<span class="keyword">sizeof</span>(SElemType));</span><br><span class="line">        <span class="keyword">if</span> (!S-&gt;base) <span class="keyword">return</span> ERROR;</span><br><span class="line">        S-&gt;top = S-&gt;base + S-&gt;stacksize;</span><br><span class="line">        S-&gt;stacksize += STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *(S-&gt;top++) = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹栈</span></span><br><span class="line"><span class="function">Status <span class="title">PopStack</span><span class="params">(SqStack *S, SElemType* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(S)) <span class="keyword">return</span> ERROR;</span><br><span class="line">    (*e) = *(--S-&gt;top);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(SqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S-&gt;top = S-&gt;base;</span><br><span class="line">    S-&gt;stacksize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">(SqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(S-&gt;base);</span><br><span class="line">    S-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    S-&gt;base = <span class="literal">NULL</span>;</span><br><span class="line">    S-&gt;stacksize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(SqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;top - S-&gt;base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历栈</span></span><br><span class="line"><span class="function">Status <span class="title">Traverse</span><span class="params">(SqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SElemType *p;</span><br><span class="line">    p = S-&gt;top - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &gt;= S-&gt;base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, *p);</span><br><span class="line">        p--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码可参见：<a href="https://github.com/Laueray/Data-Structure/blob/master/2.Stack/SqStack.c" target="_blank" rel="noopener">GitHub</a></p><h3 id="链栈-LinkStack"><a href="#链栈-LinkStack" class="headerlink" title="链栈(LinkStack)"></a>链栈(LinkStack)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;SNode, *LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(LinkStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *S = (SNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode));</span><br><span class="line">    <span class="keyword">if</span> (!(*S)) <span class="keyword">return</span> ERROR;</span><br><span class="line">    (*S)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈空</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!S-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈</span></span><br><span class="line"><span class="function">Status <span class="title">PushStack</span><span class="params">(LinkStack S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SNode *p;</span><br><span class="line">    p = (SNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode));</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> ERROR;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = S-&gt;next;</span><br><span class="line">    S-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹栈</span></span><br><span class="line"><span class="function">Status <span class="title">PopStack</span><span class="params">(LinkStack S, SElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SNode *p;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(S))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    p = S-&gt;next;</span><br><span class="line">    S-&gt;next = p-&gt;next;</span><br><span class="line">    (*e) = p-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历栈</span></span><br><span class="line"><span class="function">Status <span class="title">Traverse</span><span class="params">(LinkStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SNode *p;</span><br><span class="line">    p = S-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码可参见：<a href="https://github.com/Laueray/Data-Structure/blob/master/2.Stack/LinkStack.c" target="_blank" rel="noopener">GitHub</a></p><p><strong>DONE！</strong><br>所示代码如有错误请多加指正，谢谢</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理数据结构代码，回顾两种栈的实现方法。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.floretten.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="栈" scheme="http://blog.floretten.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>链表的实现与操作</title>
    <link href="http://blog.floretten.com/2016/LinkList/"/>
    <id>http://blog.floretten.com/2016/LinkList/</id>
    <published>2016-07-03T05:11:14.000Z</published>
    <updated>2017-10-06T04:35:37.312Z</updated>
    
    <content type="html"><![CDATA[<p>整理数据结构代码，回顾链表的实现方法。</p><a id="more"></a><h2 id="认识链表"><a href="#认识链表" class="headerlink" title="认识链表"></a>认识链表</h2><p>上一篇实现了线性表的顺序存储，本篇将实现线性表的链式存储，即链表(Linklist)的实现。链式存储的特点是用一组任意的存储单元存储线性表的数据元素。因此，为了表示每个数据元素与其直接后继元素之间的逻辑关系，对该数据元素来说，除存储本身的信息之外，还需要存储一个指示其直接后继的信息(即直接后继的存储位置)。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(LinkList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(!(*L)) <span class="keyword">return</span> ERROR;</span><br><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function">Status <span class="title">HeadInsertCreate</span><span class="params">(LinkList L,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;e);</span><br><span class="line">        LNode *p;</span><br><span class="line">        p = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        p-&gt;data = e;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function">Status <span class="title">TailInsertCreate</span><span class="params">(LinkList L,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList tail;</span><br><span class="line">    tail = L;</span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;e);</span><br><span class="line">        LNode *p;</span><br><span class="line">        p = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        p-&gt;data = e;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        tail-&gt;next = p;</span><br><span class="line">        tail = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据位置返回元素</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> pos,ElemType* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; i &lt; pos)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || i &gt; pos) <span class="keyword">return</span> ERROR;</span><br><span class="line">    (*e) = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据元素返回位置</span></span><br><span class="line"><span class="function">Status <span class="title">GetPos</span><span class="params">(LinkList L,ElemType e,<span class="keyword">int</span>* pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == e)</span><br><span class="line">        &#123;</span><br><span class="line">            (*pos) = i;</span><br><span class="line">            <span class="keyword">return</span> OK;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据位置插入元素</span></span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(LinkList L,<span class="keyword">int</span> pos,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *pre;</span><br><span class="line">    pre = L;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pre &amp;&amp; i &lt; pos<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!pre || i &gt; pos<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    LNode *p;</span><br><span class="line">    p = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = pre-&gt;next;</span><br><span class="line">    pre-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据位置删除元素</span></span><br><span class="line"><span class="function">Status <span class="title">DeleteAccordToPos</span><span class="params">(LinkList L,<span class="keyword">int</span> pos,ElemType* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *pre;</span><br><span class="line">    pre = L;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pre-&gt;next &amp;&amp; i &lt; pos<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!pre-&gt;next || i &gt; pos<span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    LNode *p;</span><br><span class="line">    p = pre-&gt;next; pre-&gt;next = p-&gt;next;</span><br><span class="line">    (*e) = p-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据值删除元素，返回位置</span></span><br><span class="line"><span class="function">Status <span class="title">DeleteAccordToElem</span><span class="params">(LinkList L,ElemType e,<span class="keyword">int</span>* pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *pre,*p;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    pre = L;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == e)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">            (*pos) = i;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">            <span class="keyword">return</span> OK;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p; <span class="comment">//记录它的前驱节点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        length++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p) length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function">Status <span class="title">Destroy</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        LNode *tmp;</span><br><span class="line">        tmp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逆置</span></span><br><span class="line"><span class="function">Status <span class="title">Inverse</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p,*q,*tmp;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    tmp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(q)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = q-&gt;next;</span><br><span class="line">        q-&gt;next = p;</span><br><span class="line">        p = q;</span><br><span class="line">        q = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function">Status <span class="title">Traverse</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码可参见：<a href="https://github.com/Laueray/Data-Structure/blob/master/1.List/Linklist.c" target="_blank" rel="noopener">GitHub</a><br><strong>DONE！</strong><br>所示代码如有错误请多加指正，谢谢</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理数据结构代码，回顾链表的实现方法。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.floretten.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="链表" scheme="http://blog.floretten.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
